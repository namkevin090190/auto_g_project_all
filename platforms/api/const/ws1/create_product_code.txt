from datetime import datetime\r\nfrom decimal import Decimal, ROUND_FLOOR, ROUND_HALF_UP\r\nfrom json import dumps, loads\r\nfrom typing import Any, Mapping, Optional, Union\r\nfrom zoneinfo import ZoneInfo\r\n\r\nfrom contracts_api import (\r\n    AccountIdShape,\r\n    ActivationHookArguments,\r\n    ActivationHookResult,\r\n    AuthorisationAdjustment,\r\n    Balance,\r\n    BalanceCoordinate,\r\n    BalanceDefaultDict,\r\n    BalancesFilter,\r\n    BalancesIntervalFetcher,\r\n    BalancesObservationFetcher,\r\n    BalanceTimeseries,\r\n    ClientTransaction,\r\n    ConversionHookArguments,\r\n    ConversionHookResult,\r\n    CustomInstruction,\r\n    DeactivationHookArguments,\r\n    DeactivationHookResult,\r\n    DEFAULT_ADDRESS,\r\n    DEFAULT_ASSET,\r\n    DefinedDateTime,\r\n    DenominationShape,\r\n    DerivedParameterHookArguments,\r\n    DerivedParameterHookResult,\r\n    fetch_account_data,\r\n    InboundAuthorisation,\r\n    InboundHardSettlement,\r\n    NumberShape,\r\n    OptionalShape,\r\n    OptionalValue,\r\n    OutboundAuthorisation,\r\n    OutboundHardSettlement,\r\n    Override,\r\n    Parameter,\r\n    ParameterLevel,\r\n    ParameterUpdatePermission,\r\n    Phase,\r\n    Posting,\r\n    PostingInstructionsDirective,\r\n    PostingInstructionType,\r\n    PostParameterChangeHookArguments,\r\n    PostParameterChangeHookResult,\r\n    PostPostingHookArguments,\r\n    PostPostingHookResult,\r\n    PrePostingHookArguments,\r\n    PrePostingHookResult,\r\n    Rejection,\r\n    RejectionReason,\r\n    RelativeDateTime,\r\n    Release,\r\n    requires,\r\n    ScheduledEvent,\r\n    ScheduledEventHookArguments,\r\n    ScheduledEventHookResult,\r\n    ScheduleExpression,\r\n    Settlement,\r\n    Shift,\r\n    SmartContractEventType,\r\n    StringShape,\r\n    TransactionCode,\r\n    Transfer,\r\n    Tside,\r\n    UnionItem,\r\n    UnionItemValue,\r\n    UnionShape,\r\n    UpdateAccountEventTypeDirective,\r\n)\r\nfrom dateutil.parser import parse\r\nfrom dateutil.relativedelta import relativedelta\r\n\r\napi = \"4.0.0\"\r\nversion = \"0.0.50\"\r\ndisplay_name = \"Current Account\"\r\ntside = Tside.LIABILITY\r\nevents_timezone = \"Asia/Ho_Chi_Minh\"\r\nglobal_parameters = [\"cut_off_time\"]\r\nsupported_denominations = [\"VND\"]\r\nsummary = (\r\n    \"A non-term deposit account (CASA) that can use for the everyday banking of the customer. This\"\r\n    \" account does not have maturity or expiration date, and it is valid as long as the account is\"\r\n    \" open.\"\r\n)\r\n\r\n\r\nZoneInfoUtc = ZoneInfo(\"UTC\")\r\nZoneInfoLocal = ZoneInfo(events_timezone)\r\n\r\n# region Constants\r\n\r\n# region event types\r\n\r\n# region Schedule events\r\n\r\nEVENT_DAILY = \"CURRENT_ACCOUNT_DAILY\"\r\n\r\n# endregion Schedule events\r\n\r\n# region Posting events\r\n\r\nEVENT_ACCRUE_INTEREST = \"CURRENT_ACCOUNT_ACCRUED_INTEREST\"\r\nEVENT_APPLY_INTEREST = \"CURRENT_ACCOUNT_APPLY_ACCRUED_INTEREST\"\r\nEVENT_REVERT_ACCRUAL_INTEREST = \"CURRENT_ACCOUNT_REVERT_ACCRUAL_INTEREST\"\r\n\r\nEVENT_TRACK_CREDIT_DAILY_LIMIT = \"CURRENT_ACCOUNT_TRACK_CREDIT_DAILY_LIMIT\"\r\nEVENT_TRACK_DEBIT_DAILY_LIMIT = \"CURRENT_ACCOUNT_TRACK_DEBIT_DAILY_LIMIT\"\r\nEVENT_TRACKING_LIMIT = \"CURRENT_ACCOUNT_TRACKING_LIMIT\"\r\n\r\nEVENT_RELEASE_CREDIT_DAILY_LIMIT = \"CURRENT_ACCOUNT_RELEASE_CREDIT_DAILY_LIMIT\"\r\nEVENT_RELEASE_DEBIT_DAILY_LIMIT = \"CURRENT_ACCOUNT_RELEASE_DEBIT_DAILY_LIMIT\"\r\nEVENT_TRACK_DEBIT_MONTHLY_LIMIT = \"CURRENT_ACCOUNT_TRACK_DEBIT_MONTHLY_LIMIT\"\r\nEVENT_RELEASE_DEBIT_MONTHLY_LIMIT = \"CURRENT_ACCOUNT_RELEASE_DEBIT_MONTHLY_LIMIT\"\r\nEVENT_REVERSE_TRACKING_BALANCES_ON_CLOSING = \"CURRENT_ACCOUNT_REVERSE_TRACKING_BALANCES_ON_CLOSING\"\r\nEVENT_CLOSE_ACCOUNT = \"CURRENT_ACCOUNT_CLOSE_ACCOUNT\"\r\n\r\n# endregion Posting events\r\n\r\n# Account schedule tags\r\nACCOUNT_SCHEDULE_TAG_ACCRUE_INTEREST = EVENT_DAILY\r\n\r\n# event types with scheduler_tag_ids\r\nevent_types = [\r\n    SmartContractEventType(name=EVENT_DAILY, scheduler_tag_ids=[\"{{account_schedule_tag_id}}\"])\r\n]\r\n\r\n# endregion event types\r\n\r\n# region account status\r\n\r\nSTATUS_ACTIVE = \"active\"\r\nSTATUS_BLOCKED = \"full_blocked\"\r\nSTATUS_DEBIT_BLOCKED = \"debit_blocked\"\r\nSTATUS_CREDIT_BLOCKED = \"credit_blocked\"\r\nSTATUS_DORMANT = \"dormant\"\r\nSTATUS_CLOSURE_REQUESTED = \"closure_requested\"\r\nSTATUS_CLOSURE_PROCESSING = \"closure_processing\"\r\nSTATUS_CLOSURE_COMPLETED = \"closure_completed\"\r\n\r\n# endregion account status\r\n\r\n# region addresses\r\n\r\nADDRESS_ACCRUAL_INTEREST = \"ACCRUAL_INTEREST\"\r\nADDRESS_INTERNAL_CONTRA = \"INTERNAL_CONTRA\"\r\n\r\n# endregion addresses\r\n\r\n# region Derived params\r\nCREDIT_DAILY_LIMIT = \"remaining_credit_daily_limit\"\r\nDEBIT_DAILY_LIMIT = \"remaining_debit_daily_limit\"\r\nDEBIT_MONTHLY_LIMIT = \"remaining_debit_monthly_limit\"\r\n\r\n# endregion Derived params\r\n\r\n# region KYC flags\r\n\r\nFLAG_VKYC = \"VKYC\"\r\n\r\n# endregion KYC flags\r\n\r\n# region KYC types\r\n\r\nTYPE_EKYC = \"EKYC\"\r\nTYPE_VKYC = \"VKYC\"\r\n\r\n# endregion KYC flags\r\n\r\n# region OTP flags\r\n\r\nSOFT_OTP = \"SOFT_OTP\"\r\n\r\n# endregion OTP flags\r\n\r\n\r\n# Limit type\r\nLIMIT_TYPE_DAILY_CREDIT = \"DAILY_CREDIT\"\r\nLIMIT_TYPE_DAILY_DEBIT = \"DAILY_DEBIT\"\r\nLIMIT_TYPE_MONTHLY_DEBIT = \"MONTHLY_DEBIT\"\r\n\r\n\r\n# region Transaction codes\r\n\r\nTRANSACTION_CODE_VIKKI_TO_VIKKI = \"VIKKI_TO_VIKKI\"\r\nTRANSACTION_CODE_VIKKI_TO_HDBANK = \"VIKKI_TO_HDBANK\"\r\nTRANSACTION_CODE_VIKKI_TO_NAPAS = \"VIKKI_TO_NAPAS\"\r\nTRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT = \"VIRTUAL_CARD_CARD_NOT_PRESENT\"\r\nTRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT = \"VIRTUAL_CARD_FX_CARD_NOT_PRESENT\"\r\n\r\nTRANSACTION_CODE_HDBANK_TO_VIKKI = \"HDBANK_TO_VIKKI\"\r\nTRANSACTION_CODE_NAPAS_TO_VIKKI = \"NAPAS_TO_VIKKI\"\r\n\r\nTRANSACTION_CODE_INTERNAL_TRANSFER = \"INTERNAL_TRANSFER\"\r\nTRANSACTION_CODE_CASA = \"CASA\"\r\nTRANSACTION_CODE_CARD = \"CARD\"\r\nTRANSACTION_CODE_E_BANKING = \"E_BANKING\"\r\n\r\n# BTC\r\nDOMAIN_ACMT = \"ACMT\"\r\nDOMAIN_PMNT = \"PMNT\"\r\n\r\nFAMILY_MCOP = \"MCOP\"\r\nFAMILY_ICDT = \"ICDT\"\r\n\r\nSUBFAMILY_INTR = \"INTR\"\r\nSUBFAMILY_VALD = \"VALD\"\r\n\r\n# Transaction type\r\nTRANS_TYPE_NAME = \"trans_type_name\"\r\nTRANSACTION_TYPE_IN = \"IN\"\r\nTRANSACTION_TYPE_IP = \"IP\"\r\nTRANSACTION_TYPE_NAME_CALCULATE_DAILY_INTEREST = \"CALCULATE DAILY INTEREST\"\r\nTRANSACTION_TYPE_NAME_PAY_INTEREST_TO_CUSTOMER = \"PAY INTEREST TO CUSTOMER\"\r\nTRANSACTION_TYPE_NAME_REVERT_CALCULATED_INTEREST = \"REVERT CALCULATED INTEREST LUMP SUM\"\r\nEVENT_TRANSACTION_TYPE_NAME = {\r\n    EVENT_ACCRUE_INTEREST: TRANSACTION_TYPE_NAME_CALCULATE_DAILY_INTEREST,\r\n    EVENT_APPLY_INTEREST: TRANSACTION_TYPE_NAME_PAY_INTEREST_TO_CUSTOMER,\r\n    EVENT_REVERT_ACCRUAL_INTEREST: TRANSACTION_TYPE_NAME_REVERT_CALCULATED_INTEREST,\r\n}\r\n# endregion Transaction codes\r\n\r\n# region Special constance\r\n\r\nSPECIAL_CUT_OFF_TIME = \"00:00:00\"\r\n\r\nPERCENTAGE_DISPLAY_PRECISION = 2\r\n\r\nTRANSACTION_CODE_SEPARATOR = \",\"\r\n\r\nRTF_POSTING_TYPE_REVERSAL = \"REVERSAL\"\r\n\r\n# Event signature set include transaction type as prefix and event digits as suffix of transaction\r\n# id\r\nEVENT_SIGNATURE_SET = {\r\n    EVENT_ACCRUE_INTEREST: (TRANSACTION_TYPE_IP, \"01\"),\r\n    EVENT_APPLY_INTEREST: (TRANSACTION_TYPE_IN, \"02\"),\r\n    EVENT_REVERT_ACCRUAL_INTEREST: (TRANSACTION_TYPE_IP, \"03\"),\r\n}\r\n\r\n# endregion Special constance\r\n\r\n# region Checking limit type\r\nDEBIT_CHECKING_LIMIT_TYPES = {\r\n    PostingInstructionType.OUTBOUND_AUTHORISATION,\r\n    PostingInstructionType.OUTBOUND_HARD_SETTLEMENT,\r\n    PostingInstructionType.TRANSFER,\r\n}\r\n\r\n\r\nCREDIT_CHECKING_LIMIT_TYPES = {\r\n    PostingInstructionType.INBOUND_AUTHORISATION,\r\n    PostingInstructionType.INBOUND_HARD_SETTLEMENT,\r\n    PostingInstructionType.TRANSFER,\r\n}\r\n\r\n\r\n# endregion Checking limit type\r\n\r\n# region Posting instructions\r\nPostingInstruction = Union[\r\n    AuthorisationAdjustment,\r\n    CustomInstruction,\r\n    InboundAuthorisation,\r\n    InboundHardSettlement,\r\n    OutboundAuthorisation,\r\n    OutboundHardSettlement,\r\n    Release,\r\n    Settlement,\r\n    Transfer,\r\n]\r\n\r\n# endregion Posting instructions\r\n\r\n# region Shape\r\n\r\nMoneyShape = NumberShape(min_value=0, step=Decimal(\"1\"))\r\nLimitShape = NumberShape(min_value=0, step=Decimal(\"1\"))\r\nRateShape = NumberShape(min_value=0, max_value=1, step=Decimal(\"0.0001\"))\r\n\r\n# endregion Shape\r\n\r\n# region Contract Violations\r\n\r\n# Transaction limit\r\nCV_001 = (\r\n    \"CV_001: Credit transaction amount {amount} {denomination} for {transaction_code} exceeds the\"\r\n    \" transaction limit of {limit} {denomination}\"\r\n)\r\nCV_002 = (\r\n    \"CV_002: Debit transaction amount {amount} {denomination} for {transaction_code} exceeds the\"\r\n    \" transaction limit of {limit} {denomination}\"\r\n)\r\n\r\n# Daily limit\r\nCV_003 = (\r\n    \"CV_003: Credit transaction amount {amount} {denomination} for {transaction_code} exceeds the\"\r\n    \" remaining daily limit of {remaining_limit} {denomination}\"\r\n)\r\nCV_004 = (\r\n    \"CV_004: Debit transaction amount {amount} {denomination} for {transaction_code} exceeds the\"\r\n    \" remaining daily limit of {remaining_limit} {denomination}\"\r\n)\r\n\r\n# Monthly limit\r\nCV_005 = (\r\n    \"CV_005: Debit transaction amount {amount} {denomination} for {transaction_code} exceeds the\"\r\n    \" remaining monthly limit of {remaining_limit} {denomination}\"\r\n)\r\n\r\n# Available balance\r\nCV_006 = (\r\n    \"CV_006: Postings amount {amount} {denomination} exceeds the available balance of\"\r\n    \" {available_balance} {denomination}.\"\r\n)\r\n\r\n# Denomination\r\nCV_007 = (\r\n    \"CV_007: Unaccepted denomination {denomination}. Accepted denomination is\"\r\n    \" {accepted_denomination}\"\r\n)\r\n\r\n# endregion\r\n\r\n# region Balance fetchers\r\n\r\n# region Balance observation fetchers\r\n\r\n\r\nBIF_ID_BEFORE_BEGINNING_OF_MONTH_FOR_MONTHLY_LIMIT_TRACKING = (\r\n    \"bif_before_beginning_of_month_for_monthly_limit_tracking\"\r\n)\r\nBEFORE_BEGINNING_OF_MONTH_FOR_MONTHLY_LIMIT_TRACKING = BalancesIntervalFetcher(\r\n    fetcher_id=BIF_ID_BEFORE_BEGINNING_OF_MONTH_FOR_MONTHLY_LIMIT_TRACKING,\r\n    start=RelativeDateTime(\r\n        # NOTE: We need to shift 1 month and 3 day to get the last day of the previous month in\r\n        # some edge cases shift 1 month is just getting the same month\r\n        # TODO: Re-configure this fetcher if vault have a better way to get the last day of the\r\n        # previous month and if vault can support local datetime for this\r\n        origin=DefinedDateTime.EFFECTIVE_DATETIME,\r\n        shift=Shift(months=-1, days=-3),\r\n        find=Override(day=27, hour=0, minute=0, second=0),\r\n    ),\r\n    end=RelativeDateTime(\r\n        origin=DefinedDateTime.EFFECTIVE_DATETIME, find=Override(day=2, hour=0, minute=0, second=0)\r\n    ),\r\n)\r\n\r\nBIF_ID_ONE_DAY_FOR_DAILY_LIMIT_TRACKING = \"bif_one_day_for_daily_limit_tracking\"\r\nONE_DAY_BALANCE = BalancesIntervalFetcher(\r\n    fetcher_id=BIF_ID_ONE_DAY_FOR_DAILY_LIMIT_TRACKING,\r\n    start=RelativeDateTime(origin=DefinedDateTime.EFFECTIVE_DATETIME, shift=Shift(days=-1)),\r\n    end=DefinedDateTime.EFFECTIVE_DATETIME,\r\n    # NOTE: Temporary remove address filter to avoid the issue of missing balance as these\r\n    # addresses are heavily depend on input of template parameters.\r\n    # TODO:We will need to align with\r\n    # upstream system so that the  filter addresses  won't be too dependent.\r\n    # filter=BalancesFilter(\r\n    #     addresses=[\r\n    #         f\"DEBIT_{CASA}_{INTERBANK_TRANSFER_CODE}\",\r\n    #         f\"DEBIT_{CASA}_{INTERNAL_TRANSFER_CODE}\",\r\n    #         f\"DEBIT_{CASA}_{BILL_PAYMENT_CODE}\",\r\n    #         f\"DEBIT_{PHYSICAL_CARD}_{ATM_CASH_WITHDRAWALS_CODE}\",\r\n    #         f\"DEBIT_{PHYSICAL_CARD}_{ATM_FX_CASH_WITHDRAWALS_CODE}\",\r\n    #         f\"DEBIT_{PHYSICAL_CARD}_{CARD_NOT_PRESENT_CODE}\",\r\n    #         f\"DEBIT_{PHYSICAL_CARD}_{CARD_PAYMENT_AT_POS_CODE}\",\r\n    #         f\"DEBIT_{PHYSICAL_CARD}_{OVERSEAS_CODE}\",\r\n    #         f\"CREDIT_{CASA}_{PULL_MONEY_FROM_NAPAS_ATM_CARD_CODE}\",\r\n    #     ]\r\n    # ),\r\n)\r\n\r\n\r\nBOF_ID_LIVE_BALANCE = \"bof_live_balance\"\r\nLIVE_BALANCE = BalancesObservationFetcher(fetcher_id=BOF_ID_LIVE_BALANCE, at=DefinedDateTime.LIVE)\r\n\r\nBOF_ID_EFFECTIVE_DATETIME_BALANCE = \"bof_effective_datetime_balance\"\r\nEFFECTIVE_DATETIME_BALANCE = BalancesObservationFetcher(\r\n    fetcher_id=BOF_ID_EFFECTIVE_DATETIME_BALANCE, at=DefinedDateTime.EFFECTIVE_DATETIME\r\n)\r\n\r\nBIF_ID_EFFECTIVE_DATETIME_BALANCE_FOR_SCHEDULE_EVENT_HOOK = (\r\n    \"bif_id_effective_datetime_balance_for_schedule_event_hook\"\r\n)\r\nEFFECTIVE_DATETIME_BALANCE_FOR_SCHEDULE_EVENT_HOOK = BalancesIntervalFetcher(\r\n    fetcher_id=BIF_ID_EFFECTIVE_DATETIME_BALANCE_FOR_SCHEDULE_EVENT_HOOK,\r\n    start=DefinedDateTime.EFFECTIVE_DATETIME,\r\n    end=DefinedDateTime.LIVE,\r\n    filter=BalancesFilter(addresses=[ADDRESS_ACCRUAL_INTEREST, DEFAULT_ADDRESS]),\r\n)\r\n\r\n# endregion Balance observation fetchers\r\n\r\n# endregion Balance fetchers\r\n\r\n\r\n# dat_fetchers\r\nbof_fetchers = [EFFECTIVE_DATETIME_BALANCE, LIVE_BALANCE]\r\nbof_fetcher_ids = [bof_fetcher.fetcher_id for bof_fetcher in bof_fetchers]\r\n\r\nbif_fetchers = [\r\n    BEFORE_BEGINNING_OF_MONTH_FOR_MONTHLY_LIMIT_TRACKING,\r\n    ONE_DAY_BALANCE,\r\n    EFFECTIVE_DATETIME_BALANCE_FOR_SCHEDULE_EVENT_HOOK,\r\n]\r\nbif_fetcher_id = [bif_fetchers.fetcher_id for bif_fetchers in bif_fetchers]\r\n\r\n\r\ndata_fetchers = [*bof_fetchers, *bif_fetchers]\r\n\r\n# endregion Constants\r\n\r\n\r\nparameters = [\r\n    # region Instance parameters\r\n    Parameter(\r\n        name=\"customer_debit_daily_limit\",\r\n        shape=OptionalShape(shape=StringShape()),\r\n        level=ParameterLevel.INSTANCE,\r\n        description=\"Debit daily limit configured by customer.\",\r\n        display_name=\"Customer's debit daily limit\",\r\n        update_permission=ParameterUpdatePermission.USER_EDITABLE,\r\n        default_value=OptionalValue(\"\"),\r\n    ),\r\n    Parameter(\r\n        name=\"status\",\r\n        shape=UnionShape(\r\n            items=[\r\n                UnionItem(key=STATUS_ACTIVE, display_name=\"Active\"),\r\n                UnionItem(key=STATUS_BLOCKED, display_name=\"Full Blocked\"),\r\n                UnionItem(key=STATUS_DEBIT_BLOCKED, display_name=\"Debit Blocked\"),\r\n                UnionItem(key=STATUS_CREDIT_BLOCKED, display_name=\"Credit Blocked\"),\r\n                UnionItem(key=STATUS_DORMANT, display_name=\"Dormant\"),\r\n                UnionItem(key=STATUS_CLOSURE_REQUESTED, display_name=\"Closure Requested\"),\r\n                UnionItem(key=STATUS_CLOSURE_PROCESSING, display_name=\"Closure Processing\"),\r\n                UnionItem(key=STATUS_CLOSURE_COMPLETED, display_name=\"Closure Completed\"),\r\n            ]\r\n        ),\r\n        level=ParameterLevel.INSTANCE,\r\n        description=\"Status of account\",\r\n        display_name=\"Account status\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=UnionItemValue(key=STATUS_ACTIVE),\r\n    ),\r\n    # endregion Instance parameters\r\n    # region Derived parameters\r\n    Parameter(\r\n        name=CREDIT_DAILY_LIMIT,\r\n        shape=StringShape(),\r\n        level=ParameterLevel.INSTANCE,\r\n        derived=True,\r\n        description=\"Remaining credit daily limit\",\r\n        display_name=\"Remaining credit daily limit\",\r\n    ),\r\n    Parameter(\r\n        name=DEBIT_DAILY_LIMIT,\r\n        shape=StringShape(),\r\n        level=ParameterLevel.INSTANCE,\r\n        derived=True,\r\n        description=\"Remaining debit daily limit\",\r\n        display_name=\"Remaining debit daily limit\",\r\n    ),\r\n    Parameter(\r\n        name=DEBIT_MONTHLY_LIMIT,\r\n        shape=StringShape(),\r\n        level=ParameterLevel.INSTANCE,\r\n        derived=True,\r\n        description=\"Remaining debit monthly limit\",\r\n        display_name=\"Remaining debit monthly limit\",\r\n    ),\r\n    # endregion Derived parameters\r\n    # region Template parameters\r\n    # region Transaction limits\r\n    Parameter(\r\n        name=\"vkyc_flags\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"Flag definition id to be used for Video KYC\",\r\n        display_name=\"Video KYC flag\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=FLAG_VKYC,\r\n    ),\r\n    Parameter(\r\n        name=\"minimum_customer_debit_daily_limit\",\r\n        shape=StringShape(),\r\n        description=\"The minimum value of customer debit daily limit for each transaction type\",\r\n        level=ParameterLevel.TEMPLATE,\r\n        display_name=\"Minimum customer debit daily limit\",\r\n        default_value=dumps(\r\n            {\r\n                TYPE_EKYC: {\r\n                    TRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT: str(1_000_000),\r\n                    TRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT: str(1_000_000),\r\n                    TRANSACTION_CODE_VIKKI_TO_NAPAS: str(50_000_000),\r\n                },\r\n                TYPE_VKYC: {\r\n                    TRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT: str(1_000_000),\r\n                    TRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT: str(1_000_000),\r\n                    TRANSACTION_CODE_VIKKI_TO_NAPAS: str(50_000_000),\r\n                },\r\n            }\r\n        ),\r\n    ),\r\n    Parameter(\r\n        name=\"credit_transaction_limit\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"The limit of credit funding can receive in one transaction\",\r\n        display_name=\"Credit transaction limit\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=dumps({SOFT_OTP: {TYPE_EKYC: {}, TYPE_VKYC: {}}}),\r\n    ),\r\n    Parameter(\r\n        name=\"debit_transaction_limit\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"The limit of debit funding can make in one transaction\",\r\n        display_name=\"Debit transaction limit\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=dumps(\r\n            {\r\n                SOFT_OTP: {\r\n                    TYPE_EKYC: {\r\n                        TRANSACTION_CODE_VIKKI_TO_VIKKI: str(100_000_000),\r\n                        TRANSACTION_CODE_VIKKI_TO_HDBANK: str(100_000_000),\r\n                        TRANSACTION_CODE_VIKKI_TO_NAPAS: str(100_000_000),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT: str(50_000_000),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT: str(0),\r\n                    },\r\n                    TYPE_VKYC: {\r\n                        TRANSACTION_CODE_VIKKI_TO_VIKKI: str(500_000_000 - 1),\r\n                        TRANSACTION_CODE_VIKKI_TO_HDBANK: str(500_000_000 - 1),\r\n                        TRANSACTION_CODE_VIKKI_TO_NAPAS: str(500_000_000 - 1),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT: str(50_000_000),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT: str(50_000_000),\r\n                    },\r\n                }\r\n            }\r\n        ),\r\n    ),\r\n    Parameter(\r\n        name=\"credit_daily_limit\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"The limit of credit funding can receive in one day\",\r\n        display_name=\"Credit daily limit\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=dumps({SOFT_OTP: {TYPE_EKYC: {}, TYPE_VKYC: {}}}),\r\n    ),\r\n    Parameter(\r\n        name=\"debit_daily_limit\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"The limit of debit funding can make in one day\",\r\n        display_name=\"Debit daily limit\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=dumps(\r\n            {\r\n                SOFT_OTP: {\r\n                    TYPE_EKYC: {\r\n                        TRANSACTION_CODE_VIKKI_TO_VIKKI: str(100_000_000),\r\n                        TRANSACTION_CODE_VIKKI_TO_HDBANK: str(100_000_000),\r\n                        TRANSACTION_CODE_VIKKI_TO_NAPAS: str(100_000_000),\r\n                        TRANSACTION_CODE_INTERNAL_TRANSFER: str(100_000_000),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT: str(50_000_000),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT: str(0),\r\n                        TRANSACTION_CODE_E_BANKING: str(100_000_000),\r\n                        TRANSACTION_CODE_CARD: str(50_000_000),\r\n                        TRANSACTION_CODE_CASA: str(100_000_000),\r\n                    },\r\n                    TYPE_VKYC: {\r\n                        TRANSACTION_CODE_VIKKI_TO_VIKKI: str(2_000_000_000),\r\n                        TRANSACTION_CODE_VIKKI_TO_HDBANK: str(2_000_000_000),\r\n                        TRANSACTION_CODE_VIKKI_TO_NAPAS: str(2_000_000_000),\r\n                        TRANSACTION_CODE_INTERNAL_TRANSFER: str(-1),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_CARD_NOT_PRESENT: str(200_000_000),\r\n                        TRANSACTION_CODE_VIRTUAL_CARD_FX_CARD_NOT_PRESENT: str(200_000_000),\r\n                        TRANSACTION_CODE_E_BANKING: str(2_000_000_000),\r\n                        TRANSACTION_CODE_CARD: str(200_000_000),\r\n                        TRANSACTION_CODE_CASA: str(2_000_000_000),\r\n                    },\r\n                }\r\n            }\r\n        ),\r\n    ),\r\n    Parameter(\r\n        name=\"debit_monthly_limit\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"The limit of debit funding can make in one month\",\r\n        display_name=\"Debit monthly limit\",\r\n        default_value=dumps(\r\n            {\r\n                SOFT_OTP: {\r\n                    TYPE_EKYC: {\r\n                        TRANSACTION_CODE_E_BANKING: str(100_000_000),\r\n                        TRANSACTION_CODE_CARD: str(100_000_000),\r\n                        TRANSACTION_CODE_CASA: str(100_000_000),\r\n                    },\r\n                    TYPE_VKYC: {\r\n                        TRANSACTION_CODE_E_BANKING: str(-1),\r\n                        TRANSACTION_CODE_CARD: str(200_000_000),\r\n                        TRANSACTION_CODE_CASA: str(-1),\r\n                    },\r\n                }\r\n            }\r\n        ),\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n    ),\r\n    # endregion Transaction limits\r\n    Parameter(\r\n        name=\"acquisition_channel\",\r\n        shape=StringShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=(\r\n            \"Acquisition channel that the product belongs to, it is purely for reporting purpose\"\r\n            \" only.\"\r\n        ),\r\n        display_name=\"Acquisition channel\",\r\n        update_permission=ParameterUpdatePermission.OPS_EDITABLE,\r\n        default_value=\"Vikki Mobile App\",\r\n    ),\r\n    # region Rate parameter\r\n    Parameter(\r\n        name=\"deposit_interest_rate\",\r\n        shape=RateShape,\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"Receive the annual standard interest rate.\",\r\n        display_name=\"Interest rate (p.a.)\",\r\n        default_value=Decimal(\"0.005\"),\r\n    ),\r\n    # endregion Rate parameter\r\n    # region General parameter\r\n    Parameter(\r\n        name=\"denomination\",\r\n        shape=DenominationShape(),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=(\r\n            \"The main currency in which the product operates. The following features will only be\"\r\n            \" available for the main denomination: deposit interest, and other fees. Contract\"\r\n            \" defined limitations will also only apply to postings made in this currency.\"\r\n        ),\r\n        display_name=\"Denomination\",\r\n        update_permission=ParameterUpdatePermission.FIXED,\r\n        default_value=\"VND\",\r\n    ),\r\n    Parameter(\r\n        name=\"interest_accrual_days_in_year\",\r\n        shape=UnionShape(items=[UnionItem(key=\"365\", display_name=\"365\")]),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description='The days in the year for interest accrual calculation. Valid values are \"365\"',\r\n        display_name=\"Interest accrual days in year\",\r\n        default_value=UnionItemValue(key=\"365\"),\r\n    ),\r\n    Parameter(\r\n        name=\"accrual_precision\",\r\n        shape=NumberShape(min_value=0, max_value=15, step=1),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"Precision needed for interest accruals.\",\r\n        display_name=\"Interest accrual precision\",\r\n        default_value=Decimal(2),\r\n    ),\r\n    Parameter(\r\n        name=\"fulfilment_precision\",\r\n        shape=NumberShape(min_value=0, max_value=4, step=1),\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"Precision needed for interest fulfilment.\",\r\n        display_name=\"Interest fulfilment precision\",\r\n        default_value=Decimal(0),\r\n    ),\r\n    Parameter(\r\n        name=\"minimum_balance\",\r\n        shape=MoneyShape,\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"Minimum balance required to maintain the account.\",\r\n        display_name=\"Minimum balance\",\r\n        default_value=Decimal(0),\r\n    ),\r\n    # endregion General parameter\r\n    # region Internal accounts\r\n    # region GL account\r\n    Parameter(\r\n        name=\"internal_account_for_interest_accrual\",\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"This is the GL account for collecting daily accrual interest\",\r\n        display_name=\"Accrual interest expense\",\r\n        shape=AccountIdShape(),\r\n        default_value=\"480100007.00\",\r\n    ),\r\n    Parameter(\r\n        name=\"internal_account_for_payable_interest\",\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"This is the GL account for collecting payable interest\",\r\n        display_name=\"Interest payables to current account\",\r\n        shape=AccountIdShape(),\r\n        default_value=\"249110001.00\",\r\n    ),\r\n    Parameter(\r\n        name=\"internal_account_for_interest_application\",\r\n        level=ParameterLevel.TEMPLATE,\r\n        description=\"This is the GL account for collecting apply interest\",\r\n        display_name=\"Interest expense - Current account\",\r\n        shape=AccountIdShape(),\r\n        default_value=\"480100003.00\",\r\n    ),\r\n    # endregion\r\n    # endregion Internal accounts\r\n    # endregion Template parameters\r\n]\r\n\r\n# region Hooks\r\n\r\n\r\n@requires(parameters=True)\r\ndef activation_hook(vault, hook_arguments: ActivationHookArguments) -> ActivationHookResult:\r\n    \"\"\"Vault hook execute at account creation\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: ActivationHookArguments\r\n    :return: ActivationHookResult object\r\n    :rtype: Optional[ActivationHookResult]\r\n    \"\"\"\r\n\r\n    # Every day at time set by template parameters\r\n    effective_datetime = hook_arguments.effective_datetime.astimezone(ZoneInfoLocal)\r\n    cut_off_time = _parse_time(_get_resolved_parameter(vault=vault, name=\"cut_off_time\"))\r\n\r\n    if not cut_off_time:\r\n        return ActivationHookResult(\r\n            scheduled_events_return_value={\r\n                EVENT_DAILY: ScheduledEvent(\r\n                    expression=ScheduleExpression(hour=0, minute=0, second=0),\r\n                    start_datetime=effective_datetime.astimezone(ZoneInfoLocal),\r\n                    skip=True,\r\n                )\r\n            }\r\n        )\r\n\r\n    cut_off_hour, cut_off_minute, cut_off_second = cut_off_time\r\n    return ActivationHookResult(\r\n        scheduled_events_return_value={\r\n            EVENT_DAILY: ScheduledEvent(\r\n                expression=ScheduleExpression(\r\n                    hour=cut_off_hour, minute=cut_off_minute, second=cut_off_second\r\n                ),\r\n                start_datetime=effective_datetime.astimezone(ZoneInfoLocal),\r\n            )\r\n        }\r\n    )\r\n\r\n\r\n@fetch_account_data(\r\n    balances=[\"bif_id_effective_datetime_balance_for_schedule_event_hook\"],\r\n    event_type=\"CURRENT_ACCOUNT_DAILY\",\r\n)\r\n@requires(\r\n    parameters=True,\r\n    flags=True,\r\n    event_type=\"CURRENT_ACCOUNT_DAILY\",\r\n    last_execution_datetime=[\"CURRENT_ACCOUNT_DAILY\"],\r\n)\r\ndef scheduled_event_hook(\r\n    vault, hook_arguments: ScheduledEventHookArguments\r\n) -> Optional[ScheduledEventHookResult]:\r\n    \"\"\"Vault hook execute by schedule\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: ScheduledEventHookArguments\r\n    :return: ScheduledEventHookResult object\r\n    :rtype: Optional[ScheduledEventHookResult]\r\n    \"\"\"\r\n\r\n    effective_datetime: datetime = hook_arguments.effective_datetime.astimezone(ZoneInfoLocal)\r\n    event_type: str = hook_arguments.event_type\r\n\r\n    posting_instructions_directives: list[PostingInstructionsDirective] = []\r\n    update_account_event_type_directives = []\r\n\r\n    if event_type == EVENT_DAILY:\r\n        effective_time_figure = (\r\n            effective_datetime.hour,\r\n            effective_datetime.minute,\r\n            effective_datetime.second,\r\n        )\r\n\r\n        last_daily_schedule_datetime = _get_last_execution_datetime(vault, event_name=EVENT_DAILY)\r\n        # Prevent duplicate posting instructions in a day when updated cut-off time\r\n        if last_daily_schedule_datetime.date() != effective_datetime.date():\r\n            balances_default_dict = _get_balance_default_dict_by_datetime(\r\n                vault=vault,\r\n                balance_interval_fetcher_id=(\r\n                    BIF_ID_EFFECTIVE_DATETIME_BALANCE_FOR_SCHEDULE_EVENT_HOOK\r\n                ),\r\n                effective_datetime=effective_datetime,\r\n            )\r\n\r\n            accrue_interest_posting_instructions = _get_accrue_interest_instructions(\r\n                vault, balance_default_dict=balances_default_dict\r\n            )\r\n\r\n            accrue_interest_client_batch_id = _get_client_batch_id(\r\n                account_id=vault.account_id, event_type=EVENT_ACCRUE_INTEREST\r\n            )\r\n\r\n            posting_instructions_directives.extend(\r\n                _get_posting_instructions_directives(\r\n                    vault=vault,\r\n                    posting_instructions=accrue_interest_posting_instructions,\r\n                    value_datetime=effective_datetime - relativedelta(microseconds=2),\r\n                    event=EVENT_ACCRUE_INTEREST,\r\n                    client_batch_id=accrue_interest_client_batch_id,\r\n                )\r\n            )\r\n\r\n            updated_balance_default_dict = _update_balance_default_dict_by_postings(\r\n                account_id=vault.account_id,\r\n                posting_instructions=accrue_interest_posting_instructions,\r\n                balance_default_dict=balances_default_dict,\r\n            )\r\n\r\n            # Apply interest at beginning of the month if cut-off-time is set to be 00:00:00\r\n            if (\r\n                effective_time_figure == _parse_time(SPECIAL_CUT_OFF_TIME)\r\n                and _is_on_first_day_of_month(effective_datetime)\r\n            ) or (\r\n                effective_time_figure != _parse_time(SPECIAL_CUT_OFF_TIME)\r\n                and _is_on_last_day_of_month(effective_datetime)\r\n            ):\r\n                interest_apply_amount = _get_apply_interest_amount(\r\n                    vault, balance_default_dict=updated_balance_default_dict\r\n                )\r\n\r\n                revert_apply_interest_posting_instructions = (\r\n                    _get_revert_apply_interest_instructions(\r\n                        vault, interest_apply_amount=interest_apply_amount\r\n                    )\r\n                )\r\n\r\n                revert_apply_interest_client_batch_id = _get_client_batch_id(\r\n                    account_id=vault.account_id, event_type=EVENT_REVERT_ACCRUAL_INTEREST\r\n                )\r\n\r\n                posting_instructions_directives.extend(\r\n                    _get_posting_instructions_directives(\r\n                        vault=vault,\r\n                        posting_instructions=revert_apply_interest_posting_instructions,\r\n                        value_datetime=effective_datetime - relativedelta(microseconds=1),\r\n                        event=EVENT_REVERT_ACCRUAL_INTEREST,\r\n                        client_batch_id=revert_apply_interest_client_batch_id,\r\n                    )\r\n                )\r\n\r\n                apply_interest_posting_instructions = _get_apply_interest_instructions(\r\n                    vault, interest_apply_amount=interest_apply_amount\r\n                )\r\n\r\n                apply_interest_client_batch_id = _get_client_batch_id(\r\n                    account_id=vault.account_id, event_type=EVENT_APPLY_INTEREST\r\n                )\r\n\r\n                posting_instructions_directives.extend(\r\n                    _get_posting_instructions_directives(\r\n                        vault=vault,\r\n                        posting_instructions=apply_interest_posting_instructions,\r\n                        value_datetime=effective_datetime - relativedelta(microseconds=1),\r\n                        event=EVENT_APPLY_INTEREST,\r\n                        client_batch_id=apply_interest_client_batch_id,\r\n                    )\r\n                )\r\n\r\n        # Update scheduled if cut-off time is changed\r\n        if (\r\n            cut_off_time := _parse_time(_get_resolved_parameter(vault, name=\"cut_off_time\"))\r\n        ) is not None and effective_time_figure != cut_off_time:\r\n            cut_off_hour, cut_off_minute, cut_off_second = cut_off_time\r\n            update_account_event_type_directives = [\r\n                UpdateAccountEventTypeDirective(\r\n                    event_type=EVENT_DAILY,\r\n                    expression=ScheduleExpression(\r\n                        hour=cut_off_hour, minute=cut_off_minute, second=cut_off_second\r\n                    ),\r\n                )\r\n            ]\r\n\r\n    return ScheduledEventHookResult(\r\n        posting_instructions_directives=(\r\n            posting_instructions_directives if posting_instructions_directives else None\r\n        ),\r\n        update_account_event_type_directives=(\r\n            update_account_event_type_directives if update_account_event_type_directives else None\r\n        ),\r\n    )\r\n\r\n\r\n@fetch_account_data(\r\n    balances=[\r\n        \"bof_live_balance\",\r\n        \"bof_effective_datetime_balance\",\r\n        \"bif_one_day_for_daily_limit_tracking\",\r\n        \"bif_before_beginning_of_month_for_monthly_limit_tracking\",\r\n    ]\r\n)\r\n@requires(parameters=True, flags=True)\r\ndef pre_posting_hook(\r\n    vault, hook_arguments: PrePostingHookArguments\r\n) -> Optional[PrePostingHookResult]:\r\n    \"\"\"Vault hook execute before posting\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: PrePostingHookArguments\r\n    :return: PrePostingHookResult object\r\n    :rtype: Optional[PrePostingHookResult]\r\n    \"\"\"\r\n\r\n    incoming_posting_instructions = hook_arguments.posting_instructions\r\n\r\n    denomination = _get_resolved_parameter(vault=vault, name=\"denomination\")\r\n\r\n    # TODO: The current vault instance (4.5.3) does not support get batch details. There are two\r\n    # way to workaround this:\r\n    #       1. Temporary ignore force posting and manual posting and wait till TM upgrade vault\r\n    #       instance to 4.6.0\r\n    #       2. Attach force posting and manual posting metadata to posting instruction_details\r\n    #       instead and align with upstream service\r\n\r\n    # if not (\r\n    #     _batch_details_to_bool(incoming_posting_instructions, batch_details_key=\"force_posting\")\r\n    # ):\r\n\r\n    # Bypass if status if `closure_processing`\r\n    if _is_current_account_status(vault, STATUS_CLOSURE_PROCESSING):\r\n        return\r\n\r\n    # Denomination check\r\n    if denomination_rejection := _get_invalid_denomination_rejection(\r\n        allowed_denomination=denomination, posting_instructions=incoming_posting_instructions\r\n    ):\r\n        return denomination_rejection\r\n\r\n    # Available balance check\r\n    if available_balance_rejection := _get_insufficient_balance_rejection(\r\n        vault, posting_instructions=incoming_posting_instructions\r\n    ):\r\n        return available_balance_rejection\r\n\r\n    # NOTE: Temporary remove manual posting and force posting check as same reason as above\r\n    # if not (\r\n    #     _batch_details_to_bool(incoming_posting_instructions, batch_details_key=\"manual_posting\")\r\n    #     or _batch_details_to_bool(incoming_posting_instructions,\r\n    #   batch_details_key=\"force_posting\")\r\n    # ):\r\n\r\n    kyc_type = _get_account_kyc(vault)\r\n    authentication_type = _get_account_authentication_method()\r\n\r\n    # Check transaction limit\r\n    if transaction_limit_rejection := _get_transaction_limit_rejection(\r\n        vault=vault,\r\n        posting_instructions=incoming_posting_instructions,\r\n        kyc_type=kyc_type,\r\n        authentication_type=authentication_type,\r\n    ):\r\n        return transaction_limit_rejection\r\n\r\n    # Check daily limit\r\n    if daily_limit_rejection := _get_daily_limit_rejection(\r\n        vault=vault,\r\n        posting_instructions=incoming_posting_instructions,\r\n        effective_datetime=hook_arguments.effective_datetime,\r\n        kyc_type=kyc_type,\r\n        authentication_type=authentication_type,\r\n    ):\r\n        return daily_limit_rejection\r\n\r\n    # check monthly limit\r\n    if monthly_limit_rejection := _get_monthly_limit_rejection(\r\n        vault=vault,\r\n        posting_instructions=incoming_posting_instructions,\r\n        effective_datetime=hook_arguments.effective_datetime,\r\n        kyc_type=kyc_type,\r\n        authentication_type=authentication_type,\r\n    ):\r\n        return monthly_limit_rejection\r\n\r\n\r\n@requires(parameters=True, flags=True)\r\ndef post_posting_hook(\r\n    vault, hook_arguments: PostPostingHookArguments\r\n) -> Optional[PostPostingHookResult]:\r\n    \"\"\"Vault hook execute after posting\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: PostPostingHookArguments\r\n    :return: PostPostingHookResult object\r\n    :rtype: Optional[PostPostingHookResult]\r\n    \"\"\"\r\n\r\n    incoming_posting_instructions = hook_arguments.posting_instructions\r\n    effective_datetime = hook_arguments.effective_datetime.astimezone(tz=ZoneInfoLocal)\r\n    client_transactions = hook_arguments.client_transactions\r\n\r\n    posting_instructions = []\r\n\r\n    # Handle daily limit tracking\r\n    posting_instructions.extend(\r\n        _get_tracking_daily_limit_instructions(\r\n            vault,\r\n            posting_instructions=incoming_posting_instructions,\r\n            client_transactions=client_transactions,\r\n            effective_datetime=effective_datetime,\r\n        )\r\n    )\r\n\r\n    # Handle monthly limit tracking\r\n    posting_instructions.extend(\r\n        _get_tracking_monthly_limit_instructions(\r\n            vault,\r\n            posting_instructions=incoming_posting_instructions,\r\n            client_transactions=client_transactions,\r\n            effective_datetime=effective_datetime,\r\n        )\r\n    )\r\n\r\n    posting_instructions_directives = _get_posting_instructions_directives(\r\n        vault=vault,\r\n        posting_instructions=posting_instructions,\r\n        value_datetime=hook_arguments.effective_datetime,\r\n        event=EVENT_TRACKING_LIMIT,\r\n    )\r\n    if posting_instructions_directives:\r\n        return PostPostingHookResult(\r\n            posting_instructions_directives=posting_instructions_directives\r\n        )\r\n\r\n\r\n@fetch_account_data(\r\n    balances=[\r\n        \"bof_effective_datetime_balance\",\r\n        \"bif_one_day_for_daily_limit_tracking\",\r\n        \"bif_before_beginning_of_month_for_monthly_limit_tracking\",\r\n    ]\r\n)\r\n@requires(parameters=True, flags=True)\r\ndef derived_parameter_hook(\r\n    vault, hook_arguments: DerivedParameterHookArguments\r\n) -> Optional[DerivedParameterHookResult]:\r\n    \"\"\"Vault hook execute on demand by calling API\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: DerivedParameterHookArguments\r\n    :return: DerivedParameterHookResult object\r\n    :rtype: Optional[DerivedParameterHookResult]\r\n    \"\"\"\r\n\r\n    (\r\n        remaining_credit_daily_limit,\r\n        remaining_debit_daily_limit,\r\n        remaining_debit_monthly_limit,\r\n    ) = _get_remaining_limits(vault, effective_datetime=hook_arguments.effective_datetime)\r\n\r\n    return DerivedParameterHookResult(\r\n        parameters_return_value={\r\n            CREDIT_DAILY_LIMIT: dumps(remaining_credit_daily_limit),\r\n            DEBIT_DAILY_LIMIT: dumps(remaining_debit_daily_limit),\r\n            DEBIT_MONTHLY_LIMIT: dumps(remaining_debit_monthly_limit),\r\n        }\r\n    )\r\n\r\n\r\n@requires(parameters=True)\r\ndef conversion_hook(vault, hook_arguments: ConversionHookArguments) -> ConversionHookResult:\r\n    \"\"\"Vault hook execute after the contract is upgraded to a new version\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: ConversionHookArguments\r\n    :return: ConversionHookResult object\r\n    :rtype: ConversionHookResult\r\n    \"\"\"\r\n\r\n    cut_off_time = _parse_time(_get_resolved_parameter(vault=vault, name=\"cut_off_time\"))\r\n\r\n    if not cut_off_time:\r\n        return ConversionHookResult(\r\n            scheduled_events_return_value={\r\n                EVENT_DAILY: ScheduledEvent(\r\n                    expression=ScheduleExpression(hour=0, minute=0, second=0), skip=True\r\n                )\r\n            }\r\n        )\r\n\r\n    cut_off_hour, cut_off_minute, cut_off_second = cut_off_time\r\n    return ConversionHookResult(\r\n        scheduled_events_return_value={\r\n            EVENT_DAILY: ScheduledEvent(\r\n                expression=ScheduleExpression(\r\n                    hour=cut_off_hour, minute=cut_off_minute, second=cut_off_second\r\n                )\r\n            )\r\n        }\r\n    )\r\n\r\n\r\n@fetch_account_data(balances=[\"bof_live_balance\"])\r\n@requires(parameters=True)\r\ndef deactivation_hook(\r\n    vault, hook_arguments: DeactivationHookArguments\r\n) -> Optional[DeactivationHookResult]:\r\n    \"\"\"Vault hook execute at account closing\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: DeactivationHookArguments\r\n    :return: DeactivationHookResult object\r\n    :rtype: Optional[DeactivationHookResult]\r\n    \"\"\"\r\n\r\n    balance_default_dict = _get_observation_balance_default_dict(vault, BOF_ID_LIVE_BALANCE)\r\n    posting_instructions = _reverse_remaining_interest_accrual(\r\n        vault, balance_default_dict=balance_default_dict\r\n    )\r\n    posting_instructions.extend(_reverse_tracking_limits(vault))\r\n\r\n    posting_instructions_directives = _get_posting_instructions_directives(\r\n        vault=vault,\r\n        posting_instructions=posting_instructions,\r\n        value_datetime=hook_arguments.effective_datetime,\r\n        event=EVENT_CLOSE_ACCOUNT,\r\n    )\r\n\r\n    if posting_instructions_directives:\r\n        return DeactivationHookResult(\r\n            posting_instructions_directives=posting_instructions_directives\r\n        )\r\n\r\n\r\n@fetch_account_data(balances=[\"bof_live_balance\"])\r\n@requires(parameters=True)\r\ndef post_parameter_change_hook(\r\n    vault, hook_arguments: PostParameterChangeHookArguments\r\n) -> Optional[PostParameterChangeHookResult]:\r\n    \"\"\"Vault hook execute after changing parameter\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param hook_arguments: Hook arguments\r\n    :type hook_arguments: PostParameterChangeHookArguments\r\n    :return: PostParameterChangeHookResult object\r\n    :rtype: Optional[PostParameterChangeHookResult]\r\n    \"\"\"\r\n    old_parameter_values = hook_arguments.old_parameter_values\r\n    updated_parameter_values = hook_arguments.updated_parameter_values\r\n    effective_datetime = hook_arguments.effective_datetime\r\n    posting_instructions_directives: list[PostingInstructionsDirective] = []\r\n\r\n    if (\r\n        _has_parameter_value_changed(\"status\", old_parameter_values, updated_parameter_values)\r\n        and _get_parameter_value(parameter=updated_parameter_values[\"status\"], union=True)\r\n        == STATUS_CLOSURE_PROCESSING\r\n    ):\r\n        balance_default_dict = _get_observation_balance_default_dict(vault, BOF_ID_LIVE_BALANCE)\r\n\r\n        interest_apply_amount = _get_apply_interest_amount(\r\n            vault, balance_default_dict=balance_default_dict\r\n        )\r\n\r\n        revert_apply_interest_posting_instructions = _get_revert_apply_interest_instructions(\r\n            vault, interest_apply_amount=interest_apply_amount\r\n        )\r\n\r\n        revert_apply_interest_client_batch_id = _get_client_batch_id(\r\n            account_id=vault.account_id, event_type=EVENT_REVERT_ACCRUAL_INTEREST\r\n        )\r\n\r\n        posting_instructions_directives.extend(\r\n            _get_posting_instructions_directives(\r\n                vault=vault,\r\n                posting_instructions=revert_apply_interest_posting_instructions,\r\n                value_datetime=effective_datetime,\r\n                event=EVENT_REVERT_ACCRUAL_INTEREST,\r\n                client_batch_id=revert_apply_interest_client_batch_id,\r\n            )\r\n        )\r\n\r\n        apply_interest_posting_instructions = _get_apply_interest_instructions(\r\n            vault, interest_apply_amount=interest_apply_amount\r\n        )\r\n\r\n        apply_interest_client_batch_id = _get_client_batch_id(\r\n            account_id=vault.account_id, event_type=EVENT_APPLY_INTEREST\r\n        )\r\n\r\n        posting_instructions_directives.extend(\r\n            _get_posting_instructions_directives(\r\n                vault=vault,\r\n                posting_instructions=apply_interest_posting_instructions,\r\n                value_datetime=effective_datetime,\r\n                event=EVENT_APPLY_INTEREST,\r\n                client_batch_id=apply_interest_client_batch_id,\r\n            )\r\n        )\r\n\r\n    if posting_instructions_directives:\r\n        return PostParameterChangeHookResult(\r\n            posting_instructions_directives=posting_instructions_directives\r\n        )\r\n\r\n\r\n# endregion Hooks\r\n\r\n\r\n# region Scheduled event hook helpers\r\n\r\n\r\ndef _get_accrue_interest_instructions(\r\n    vault, *, balance_default_dict: BalanceDefaultDict\r\n) -> list[CustomInstruction]:\r\n    \"\"\"Calculate the daily interest upon interest accrual balance\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param balances: The balance used to retrieve interest accrual balance for calculate interest\r\n    :type balances: str\r\n    :param effective_datetime: The effective datetime of the event\r\n    :type effective_datetime: datetime\r\n    :return: List of posting instructions for accrual interest\r\n    :rtype: list[PostingInstruction]\r\n    \"\"\"\r\n\r\n    def _get_actual_balance(vault, *, balance_default_dict: BalanceDefaultDict) -> Decimal:\r\n        \"\"\"Get the balance of the account that can be calculating interest accrual upon\r\n\r\n        :param vault: Vault object\r\n        :type vault:\r\n        :param balance_default_dict: The balance_default_dict to retrieve balance\r\n        :type balance_default_dict: BalanceDefaultDict\r\n        :return: The interest accrual balance of the account. If the interest accrual balance is\r\n            negative, return 0\r\n        :rtype: Decimal\r\n        \"\"\"\r\n\r\n        return max(\r\n            Decimal(0),\r\n            _get_balance_sum(\r\n                vault=vault,\r\n                addresses=[DEFAULT_ADDRESS],\r\n                balances_default_dict=balance_default_dict,\r\n                phase=Phase.COMMITTED,\r\n            ),\r\n        )\r\n\r\n    actual_balance = _get_actual_balance(vault, balance_default_dict=balance_default_dict)\r\n\r\n    if _is_current_account_status(vault, STATUS_CLOSURE_PROCESSING) or _is_current_account_status(\r\n        vault, STATUS_CLOSURE_COMPLETED\r\n    ):\r\n        return []\r\n\r\n    days_in_year = Decimal(\r\n        _get_resolved_parameter(vault=vault, name=\"interest_accrual_days_in_year\", is_union=True)\r\n    )\r\n    denomination = _get_resolved_parameter(vault=vault, name=\"denomination\")\r\n    annual_interest_rate = _get_resolved_parameter(vault=vault, name=\"deposit_interest_rate\")\r\n    daily_interest_rate = annual_interest_rate / days_in_year\r\n\r\n    accrual_interest_address_balance = _get_balance_sum(\r\n        vault, addresses=[ADDRESS_ACCRUAL_INTEREST], balances_default_dict=balance_default_dict\r\n    )\r\n    accrual_interest_amount = _calculate_accrual_interest_amount(\r\n        vault, actual_balance=actual_balance, daily_interest_rate=daily_interest_rate\r\n    )\r\n\r\n    fulfilment_precision = int(_get_resolved_parameter(vault, \"fulfilment_precision\"))\r\n    frac_accrual_interest_address_balance = accrual_interest_address_balance - _round_decimal(\r\n        accrual_interest_address_balance, fulfilment_precision, ROUND_FLOOR\r\n    )\r\n    internal_accrual_interest_amount = _round_decimal(\r\n        accrual_interest_amount + frac_accrual_interest_address_balance,\r\n        fulfilment_precision,\r\n        ROUND_FLOOR,\r\n    )\r\n\r\n    if accrual_interest_amount <= 0:\r\n        return []\r\n\r\n    postings = [\r\n        _move_funds_between_vault_accounts(\r\n            vault=vault,\r\n            amount=accrual_interest_amount,\r\n            event=EVENT_ACCRUE_INTEREST,\r\n            from_account_address=ADDRESS_INTERNAL_CONTRA,\r\n            to_account_address=ADDRESS_ACCRUAL_INTEREST,\r\n            instruction_details={\r\n                \"description\": (\r\n                    \"Daily interest accrued at\"\r\n                    f\" {daily_interest_rate * 100:.{PERCENTAGE_DISPLAY_PRECISION}f}% on balance of\"\r\n                    f\" {actual_balance} {denomination}.\"\r\n                )\r\n            },\r\n        )\r\n    ]\r\n    if internal_accrual_interest_amount > 0:\r\n        internal_account_for_interest_accrual = _get_resolved_parameter(\r\n            vault=vault, name=\"internal_account_for_interest_accrual\"\r\n        )\r\n        internal_account_for_payable_interest = _get_resolved_parameter(\r\n            vault=vault, name=\"internal_account_for_payable_interest\"\r\n        )\r\n        postings.append(\r\n            _move_funds_between_vault_accounts(\r\n                vault=vault,\r\n                amount=internal_accrual_interest_amount,\r\n                event=EVENT_ACCRUE_INTEREST,\r\n                from_account_id=internal_account_for_interest_accrual,\r\n                to_account_id=internal_account_for_payable_interest,\r\n                instruction_details={\r\n                    \"description\": \"Internal Account booking for daily interest accrual\"\r\n                },\r\n                transaction_code=TransactionCode(\r\n                    domain=DOMAIN_ACMT, family=FAMILY_MCOP, subfamily=SUBFAMILY_INTR\r\n                ),\r\n            )\r\n        )\r\n    return postings\r\n\r\n\r\ndef _calculate_accrual_interest_amount(\r\n    vault, *, actual_balance: Decimal, daily_interest_rate: Decimal\r\n) -> Decimal:\r\n    \"\"\"Calculate the daily interest upon interest accrual balance\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param actual_balance: The balance used to calculate interest\r\n    :type actual_balance: Decimal\r\n    :param daily_interest_rate: The daily interest rate\r\n    :type daily_interest_rate: Decimal\r\n    :return: The amount of interest accrued\r\n    :rtype: Decimal\r\n    \"\"\"\r\n\r\n    accrual_precision = int(_get_resolved_parameter(vault, \"accrual_precision\"))\r\n    accrual_interest_amount = _round_decimal(\r\n        daily_interest_rate * actual_balance, accrual_precision\r\n    )\r\n\r\n    return accrual_interest_amount\r\n\r\n\r\ndef _get_apply_interest_amount(vault, *, balance_default_dict: BalanceDefaultDict) -> Decimal:\r\n    \"\"\"Calculate the apply interest amount to apply to customer and revert to bank\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param balance_default_dict: The `balance_default_dict` used to calculate apply interest amount\r\n    :type balance_default_dict: BalanceDefaultDict\r\n    :return: The apply interest amount\r\n    :rtype: Decimal\r\n    \"\"\"\r\n    fulfilment_precision = int(_get_resolved_parameter(vault, \"fulfilment_precision\"))\r\n    interest_apply_amount = _round_decimal(\r\n        _get_balance_sum(\r\n            vault, addresses=[ADDRESS_ACCRUAL_INTEREST], balances_default_dict=balance_default_dict\r\n        ),\r\n        fulfilment_precision,\r\n        ROUND_FLOOR,\r\n    )\r\n    return interest_apply_amount\r\n\r\n\r\ndef _get_apply_interest_instructions(\r\n    vault, *, interest_apply_amount: Decimal\r\n) -> list[CustomInstruction]:\r\n    \"\"\"Processes any accrued interest by either applying it to the customers default account\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param interest_apply_amount: The `interest_apply_amount` used to apply interest amount\r\n    :type interest_apply_amount: Decimal\r\n    :return: List of posting instructions directive contain posting for apply interest\r\n    :rtype: list[PostingInstructionDirective]\r\n    \"\"\"\r\n    if interest_apply_amount <= 0:\r\n        return []\r\n\r\n    internal_account_for_interest_application = _get_resolved_parameter(\r\n        vault=vault, name=\"internal_account_for_interest_application\"\r\n    )\r\n\r\n    posting_instructions = [\r\n        _move_funds_between_vault_accounts(\r\n            vault=vault,\r\n            amount=interest_apply_amount,\r\n            from_account_id=internal_account_for_interest_application,\r\n            instruction_details={\"description\": \"Accrued interest applied\"},\r\n            event=EVENT_APPLY_INTEREST,\r\n            transaction_code=TransactionCode(\r\n                domain=DOMAIN_PMNT, family=FAMILY_ICDT, subfamily=SUBFAMILY_INTR\r\n            ),\r\n        ),\r\n        # Internal account booking for apply interest\r\n    ]\r\n\r\n    return posting_instructions\r\n\r\n\r\ndef _get_revert_apply_interest_instructions(\r\n    vault, *, interest_apply_amount: Decimal\r\n) -> list[CustomInstruction]:\r\n    \"\"\"Reversing and returning the accrued amounts back to the bank.\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param interest_apply_amount: The `interest_apply_amount` used to revert interest amount\r\n    :type interest_apply_amount: Decimal\r\n    :return: List of posting instructions directive contain posting for revert apply interest\r\n    :rtype: list[PostingInstructionDirective]\r\n    \"\"\"\r\n    if interest_apply_amount <= 0:\r\n        return []\r\n\r\n    internal_account_for_interest_accrual = _get_resolved_parameter(\r\n        vault=vault, name=\"internal_account_for_interest_accrual\"\r\n    )\r\n    internal_account_for_payable_interest = _get_resolved_parameter(\r\n        vault=vault, name=\"internal_account_for_payable_interest\"\r\n    )\r\n\r\n    posting_instructions = [\r\n        _move_funds_between_vault_accounts(\r\n            vault=vault,\r\n            amount=interest_apply_amount,\r\n            from_account_address=ADDRESS_ACCRUAL_INTEREST,\r\n            to_account_address=ADDRESS_INTERNAL_CONTRA,\r\n            instruction_details={\"description\": \"Revert of daily accrual interest\"},\r\n            event=EVENT_REVERT_ACCRUAL_INTEREST,\r\n        ),\r\n        # Internal account booking for revert of daily accrual interest\r\n        _move_funds_between_vault_accounts(\r\n            vault=vault,\r\n            amount=interest_apply_amount,\r\n            from_account_id=internal_account_for_payable_interest,\r\n            to_account_id=internal_account_for_interest_accrual,\r\n            instruction_details={\r\n                \"description\": \"Internal Account booking for revert of daily accrual interest\"\r\n            },\r\n            event=EVENT_REVERT_ACCRUAL_INTEREST,\r\n            transaction_code=TransactionCode(\r\n                domain=DOMAIN_ACMT, family=FAMILY_MCOP, subfamily=SUBFAMILY_VALD\r\n            ),\r\n        )\r\n        # Internal account booking for apply interest\r\n    ]\r\n\r\n    return posting_instructions\r\n\r\n\r\n# endregion Scheduled event hook helpers\r\n\r\n# region Pre posting hook helpers\r\n\r\n\r\ndef _get_invalid_denomination_rejection(\r\n    *, allowed_denomination: str, posting_instructions: list[PostingInstruction]\r\n) -> Optional[PrePostingHookResult]:\r\n    \"\"\"Check if all denomination in posting instruction is allowed one\r\n\r\n    :param allowed_denomination: The only allowed currency for this product\r\n    :type allowed_denomination: str\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: List[PostingInstruction]\r\n    :return: Rejection if any non-allowed denomination found\r\n    :rtype: Optional[PrePostingHookResult]\r\n    \"\"\"\r\n\r\n    def _get_denomination_rejection(denomination: str) -> PrePostingHookResult:\r\n        return PrePostingHookResult(\r\n            rejection=Rejection(\r\n                message=CV_007.format(\r\n                    denomination=denomination, accepted_denomination=allowed_denomination\r\n                ),\r\n                reason_code=RejectionReason.WRONG_DENOMINATION,\r\n            )\r\n        )\r\n\r\n    for posting_instruction in posting_instructions:\r\n        # Separate check for `CUSTOM_INSTRUCTION`\r\n        if (\r\n            (custom_instruction := posting_instruction).type\r\n        ) is PostingInstructionType.CUSTOM_INSTRUCTION:\r\n            for posting in custom_instruction.postings:\r\n                if (denomination := posting.denomination) != allowed_denomination:\r\n                    return _get_denomination_rejection(posting.denomination)\r\n\r\n        # Other type of posting instructions\r\n        elif (denomination := posting_instruction.denomination) != allowed_denomination:\r\n            return _get_denomination_rejection(denomination)\r\n\r\n\r\ndef _get_insufficient_balance_rejection(\r\n    vault, *, posting_instructions: list[PostingInstruction]\r\n) -> Optional[PrePostingHookResult]:\r\n    \"\"\"Check if available balance is enough for all posting instructions\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :return: Rejection if available balance is not enough\r\n    :rtype: Optional[PrePostingHookResult]\r\n    \"\"\"\r\n\r\n    balance_default_dict = _get_observation_balance_default_dict(\r\n        vault=vault, balance_observation_fetcher_id=BOF_ID_LIVE_BALANCE\r\n    )\r\n    available_balance = _get_available_balance(vault, balance_default_dict=balance_default_dict)\r\n\r\n    total_debit_amount = Decimal(0)\r\n    for posting_instruction in posting_instructions:\r\n        if (posting_amount := _get_posting_amount(vault, posting_instruction)) > 0:\r\n            continue\r\n        total_debit_amount += posting_amount\r\n\r\n        if abs(total_debit_amount) <= available_balance:\r\n            continue\r\n\r\n        return PrePostingHookResult(\r\n            rejection=Rejection(\r\n                message=CV_006.format(\r\n                    amount=str(abs(total_debit_amount)),\r\n                    denomination=_get_resolved_parameter(vault, \"denomination\"),\r\n                    available_balance=str(available_balance),\r\n                ),\r\n                reason_code=RejectionReason.INSUFFICIENT_FUNDS,\r\n            )\r\n        )\r\n\r\n\r\ndef _get_transaction_limit_rejection(\r\n    vault,\r\n    *,\r\n    posting_instructions: list[PostingInstruction],\r\n    kyc_type: str,\r\n    authentication_type: str,\r\n) -> Optional[PrePostingHookResult]:\r\n    \"\"\"Check if all posting instructions are within transaction limit\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param kyc_type: kyc type of the account\r\n    :type kyc_type: str\r\n    :param authentication_type: authentication type of the account\r\n    :type authentication_type: str\r\n    :return: Rejection if any posting instruction is not within transaction limit\r\n    :rtype: Optional[PrePostingHookResult]\r\n    \"\"\"\r\n\r\n    debit_transaction_limit = _get_resolved_parameter(\r\n        vault, \"debit_transaction_limit\", is_json=True\r\n    )\r\n    debit_transaction_limit = debit_transaction_limit[authentication_type][kyc_type]\r\n    credit_transaction_limit = _get_resolved_parameter(\r\n        vault, \"credit_transaction_limit\", is_json=True\r\n    )\r\n    credit_transaction_limit = credit_transaction_limit[authentication_type][kyc_type]\r\n    denomination = _get_resolved_parameter(vault, \"denomination\")\r\n    for posting_instruction in posting_instructions:\r\n        # We only check some of posting types\r\n        if posting_instruction.type not in DEBIT_CHECKING_LIMIT_TYPES | CREDIT_CHECKING_LIMIT_TYPES:\r\n            continue\r\n\r\n        # We allow all postings with no transaction code\r\n        if not (\r\n            transaction_codes := posting_instruction.instruction_details.get(\"transaction_code\")\r\n        ):\r\n            continue\r\n        transaction_codes = map(str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR))\r\n\r\n        amount = _get_posting_amount(vault, posting_instruction)\r\n\r\n        # Credit posting\r\n        if amount > 0:\r\n            for transaction_code in transaction_codes:\r\n                limit = Decimal(credit_transaction_limit.get(transaction_code, -1))\r\n                if not (amount > limit >= 0):\r\n                    continue\r\n                return PrePostingHookResult(\r\n                    rejection=Rejection(\r\n                        message=CV_001.format(\r\n                            amount=str(amount),\r\n                            transaction_code=transaction_code,\r\n                            limit=str(limit),\r\n                            denomination=denomination,\r\n                        ),\r\n                        reason_code=RejectionReason.AGAINST_TNC,\r\n                    )\r\n                )\r\n        # Debit posting\r\n        elif amount < 0:\r\n            for transaction_code in transaction_codes:\r\n                limit = Decimal(debit_transaction_limit.get(transaction_code, -1))\r\n                if not (abs(amount) > limit >= 0):\r\n                    continue\r\n                return PrePostingHookResult(\r\n                    rejection=Rejection(\r\n                        message=CV_002.format(\r\n                            amount=str(abs(amount)),\r\n                            transaction_code=transaction_code,\r\n                            limit=str(limit),\r\n                            denomination=denomination,\r\n                        ),\r\n                        reason_code=RejectionReason.AGAINST_TNC,\r\n                    )\r\n                )\r\n\r\n\r\ndef _get_daily_limit_rejection(\r\n    vault,\r\n    *,\r\n    posting_instructions: list[PostingInstruction],\r\n    effective_datetime: datetime,\r\n    kyc_type: str,\r\n    authentication_type: str,\r\n) -> Optional[PrePostingHookResult]:\r\n    \"\"\"Check if all posting instructions are within daily limit\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param effective_datetime: The effective datetime of the event\r\n    :type effective_datetime: datetime\r\n    :param kyc_type: kyc type of the account\r\n    :type kyc_type: str\r\n    :param authentication_type: authentication type of the account\r\n    :type authentication_type: str\r\n    :return: Rejection if any posting instruction is not within daily limit\r\n    :rtype: Optional[PrePostingHookResult]\r\n    \"\"\"\r\n\r\n    debit_daily_limit = _get_debit_daily_limit(vault)[authentication_type][kyc_type]\r\n    credit_daily_limit = _get_credit_daily_limit(vault)[authentication_type][kyc_type]\r\n    denomination = _get_resolved_parameter(vault, \"denomination\")\r\n    before_midnight = _get_beginning_of_day(effective_datetime) - relativedelta(microseconds=1)\r\n\r\n    address_to_delta_balance = {}\r\n\r\n    for posting_instruction in posting_instructions:\r\n        # We only check some of posting types\r\n        if posting_instruction.type not in DEBIT_CHECKING_LIMIT_TYPES | CREDIT_CHECKING_LIMIT_TYPES:\r\n            continue\r\n\r\n        # We allow all postings with no transaction code\r\n        if not (\r\n            transaction_codes := posting_instruction.instruction_details.get(\"transaction_code\")\r\n        ):\r\n            continue\r\n\r\n        transaction_codes = map(str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR))\r\n\r\n        amount = _get_posting_amount(vault, posting_instruction)\r\n\r\n        # Credit posting\r\n        if amount > 0 and posting_instruction.type in CREDIT_CHECKING_LIMIT_TYPES:\r\n            for transaction_code in transaction_codes:\r\n                # We allow all transactions with an unknown transaction code\r\n                if (limit := Decimal(credit_daily_limit.get(transaction_code, -1))) < 0:\r\n                    continue\r\n                address = f\"{LIMIT_TYPE_DAILY_CREDIT}_{transaction_code}\"\r\n\r\n                # Remember the delta balance for each address across all postings\r\n                if address not in address_to_delta_balance:\r\n                    address_to_delta_balance[address] = _get_balance_sum(\r\n                        vault=vault,\r\n                        addresses=[address],\r\n                        fetcher_id=BOF_ID_EFFECTIVE_DATETIME_BALANCE,\r\n                    ) - _get_balance_sum(\r\n                        vault=vault,\r\n                        addresses=[address],\r\n                        fetcher_id=BIF_ID_ONE_DAY_FOR_DAILY_LIMIT_TRACKING,\r\n                        timestamp=before_midnight,\r\n                    )\r\n                delta_balance = address_to_delta_balance[address]\r\n\r\n                if abs(amount) + delta_balance <= limit:\r\n                    address_to_delta_balance[address] = abs(amount) + delta_balance\r\n                    continue\r\n\r\n                return PrePostingHookResult(\r\n                    rejection=Rejection(\r\n                        message=CV_003.format(\r\n                            amount=str(abs(amount)),\r\n                            transaction_code=transaction_code,\r\n                            remaining_limit=str(max(0, limit - delta_balance)),\r\n                            denomination=denomination,\r\n                        ),\r\n                        reason_code=RejectionReason.AGAINST_TNC,\r\n                    )\r\n                )\r\n\r\n        # Debit posting\r\n        elif amount < 0 and posting_instruction.type in DEBIT_CHECKING_LIMIT_TYPES:\r\n            for transaction_code in transaction_codes:\r\n                # We allow all transactions with an unknown transaction code\r\n                if (limit := Decimal(debit_daily_limit.get(transaction_code, -1))) < 0:\r\n                    continue\r\n                address = f\"{LIMIT_TYPE_DAILY_DEBIT}_{transaction_code}\"\r\n\r\n                # Remember the delta balance for each address across all postings\r\n                if address not in address_to_delta_balance:\r\n                    address_to_delta_balance[address] = _get_balance_sum(\r\n                        vault=vault,\r\n                        addresses=[address],\r\n                        fetcher_id=BOF_ID_EFFECTIVE_DATETIME_BALANCE,\r\n                    ) - _get_balance_sum(\r\n                        vault=vault,\r\n                        addresses=[address],\r\n                        fetcher_id=BIF_ID_ONE_DAY_FOR_DAILY_LIMIT_TRACKING,\r\n                        timestamp=before_midnight,\r\n                    )\r\n                delta_balance = address_to_delta_balance[address]\r\n\r\n                if abs(amount) + delta_balance <= limit:\r\n                    address_to_delta_balance[address] = abs(amount) + delta_balance\r\n                    continue\r\n\r\n                return PrePostingHookResult(\r\n                    rejection=Rejection(\r\n                        message=CV_004.format(\r\n                            amount=str(abs(amount)),\r\n                            transaction_code=transaction_code,\r\n                            remaining_limit=str(max(0, limit - delta_balance)),\r\n                            denomination=denomination,\r\n                        ),\r\n                        reason_code=RejectionReason.AGAINST_TNC,\r\n                    )\r\n                )\r\n\r\n\r\ndef _get_monthly_limit_rejection(\r\n    vault,\r\n    posting_instructions: list[PostingInstruction],\r\n    effective_datetime: datetime,\r\n    kyc_type: str,\r\n    authentication_type: str,\r\n) -> Optional[PrePostingHookResult]:\r\n    \"\"\"Check if all posting instructions are within monthly limit\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param effective_datetime: The effective datetime of the event\r\n    :type effective_datetime: datetime\r\n    :param kyc_type: kyc type of the account\r\n    :type kyc_type: str\r\n    :param authentication_type: authentication type of the account\r\n    :type authentication_type: str\r\n    :return: Rejection if any posting instruction is not within monthly limit\r\n    :rtype: Optional[PrePostingHookResult]\r\n    \"\"\"\r\n\r\n    debit_monthly_limit = _get_debit_monthly_limit(vault)[authentication_type][kyc_type]\r\n    denomination = _get_resolved_parameter(vault, \"denomination\")\r\n    address_to_delta_balance = {}\r\n\r\n    before_beginning_of_month = _get_beginning_of_month(effective_datetime) - relativedelta(\r\n        microseconds=1\r\n    )\r\n\r\n    for posting_instruction in posting_instructions:\r\n        if posting_instruction.type not in DEBIT_CHECKING_LIMIT_TYPES:\r\n            continue\r\n\r\n        if not (\r\n            transaction_codes := posting_instruction.instruction_details.get(\"transaction_code\")\r\n        ):\r\n            continue\r\n\r\n        if (amount := _get_posting_amount(vault, posting_instruction)) >= 0:\r\n            continue\r\n\r\n        for transaction_code in map(str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)):\r\n            if (limit := Decimal(debit_monthly_limit.get(transaction_code, -1))) < 0:\r\n                continue\r\n            address = f\"{LIMIT_TYPE_MONTHLY_DEBIT}_{transaction_code}\"\r\n\r\n            # Remember the delta balance for each address across all postings\r\n            if address not in address_to_delta_balance:\r\n                address_to_delta_balance[address] = _get_balance_sum(\r\n                    vault=vault, addresses=[address], fetcher_id=BOF_ID_EFFECTIVE_DATETIME_BALANCE\r\n                ) - _get_balance_sum(\r\n                    vault=vault,\r\n                    addresses=[address],\r\n                    fetcher_id=BIF_ID_BEFORE_BEGINNING_OF_MONTH_FOR_MONTHLY_LIMIT_TRACKING,\r\n                    timestamp=before_beginning_of_month,\r\n                )\r\n            delta_balance = address_to_delta_balance[address]\r\n\r\n            if abs(amount) + delta_balance <= limit:\r\n                address_to_delta_balance[address] = abs(amount) + delta_balance\r\n                continue\r\n            return PrePostingHookResult(\r\n                rejection=Rejection(\r\n                    message=CV_005.format(\r\n                        amount=str(abs(amount)),\r\n                        transaction_code=transaction_code,\r\n                        remaining_limit=str(max(0, limit - delta_balance)),\r\n                        denomination=denomination,\r\n                    ),\r\n                    reason_code=RejectionReason.AGAINST_TNC,\r\n                )\r\n            )\r\n\r\n\r\n# endregion Pre posting hook helpers\r\n\r\n\r\n# region Post posting hook helpers\r\ndef _get_original_posting_transaction_codes(\r\n    *,\r\n    posting_instruction: PostingInstruction,\r\n    client_transactions: dict[str, ClientTransaction],\r\n    original_posting_type: str,\r\n    effective_datetime: datetime,\r\n    is_month_limit: Optional[bool] = False,\r\n) -> Optional[str]:\r\n    \"\"\"Check posting type and posting date time in case releasing posting\r\n\r\n    :param posting_instruction: The posting instruction\r\n    :type posting_instruction: PostingInstruction\r\n    :param client_transactions: The mapping of unique_client_transaction_id and\r\n    ClientTransaction\r\n    :type client_transactions: dict[str, ClientTransaction]\r\n    :param original_posting_type: The type of posting\r\n    :type original_posting_type: str\r\n    :param effective_datetime: The effective datetime\r\n    :type effective_datetime: datetime\r\n    :param is_month_limit: If true, check reverse posting according to month\r\n    :type is_month_limit: Optional[bool]\r\n    :return: The transaction code of original posting\r\n    :rtype: Optional[str]\r\n    \"\"\"\r\n\r\n    client_transaction = client_transactions.get(posting_instruction.unique_client_transaction_id)\r\n    effective_date = (\r\n        effective_datetime.date().replace(day=1) if is_month_limit else effective_datetime.date()\r\n    )\r\n\r\n    for posting_instruction in client_transaction.posting_instructions:\r\n        posting_instruction_date = (\r\n            posting_instruction.value_datetime.astimezone(tz=ZoneInfoLocal).date().replace(day=1)\r\n            if is_month_limit\r\n            else posting_instruction.value_datetime.astimezone(tz=ZoneInfoLocal).date()\r\n        )\r\n\r\n        if (\r\n            posting_instruction.type == original_posting_type\r\n            and posting_instruction_date == effective_date\r\n        ):\r\n            return posting_instruction.instruction_details.get(\"transaction_code\")\r\n\r\n\r\ndef _get_tracking_daily_limit_instructions(\r\n    vault,\r\n    *,\r\n    posting_instructions: list[PostingInstruction],\r\n    client_transactions: dict[str, ClientTransaction],\r\n    effective_datetime: datetime,\r\n) -> list[CustomInstruction]:\r\n    \"\"\"Track daily limit for all posting instructions\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param client_transactions: The dictionary of client transaction in hook arguments\r\n    :type client_transactions: dict[str, ClientTransaction]\r\n    :param effective_datetime: The effective datetime of the posting batch\r\n    :type effective_datetime: datetime\r\n    :return: List of posting instructions for tracking daily limit\r\n    :rtype: list[PostingInstruction]\r\n    \"\"\"\r\n\r\n    kyc_type = _get_account_kyc(vault)\r\n    authentication_type = _get_account_authentication_method()\r\n    debit_daily_limit = _get_debit_daily_limit(vault)[authentication_type][kyc_type]\r\n    credit_daily_limit = _get_credit_daily_limit(vault)[authentication_type][kyc_type]\r\n\r\n    tracking_daily_limit_posting_instructions = []\r\n    for posting_instruction in posting_instructions:\r\n        # Credit posting\r\n        if (amount := _get_posting_amount(vault, posting_instruction)) > 0:\r\n            # Revert the amount of debit limit if the posting is released within a day\r\n            if (\r\n                posting_instruction.type\r\n                in [PostingInstructionType.RELEASE, PostingInstructionType.SETTLEMENT]\r\n                and (\r\n                    transaction_codes := _get_original_posting_transaction_codes(\r\n                        posting_instruction=posting_instruction,\r\n                        client_transactions=client_transactions,\r\n                        original_posting_type=PostingInstructionType.OUTBOUND_AUTHORISATION,\r\n                        effective_datetime=effective_datetime,\r\n                    )\r\n                )\r\n            ) or (\r\n                posting_instruction.type is PostingInstructionType.INBOUND_HARD_SETTLEMENT\r\n                and posting_instruction.instruction_details.get(\"rtf_posting_type\")\r\n                == RTF_POSTING_TYPE_REVERSAL\r\n                and (\r\n                    transmission_datetime := posting_instruction.instruction_details.get(\r\n                        \"transmission_datetime\"\r\n                    )\r\n                )\r\n                and parse(transmission_datetime).astimezone(ZoneInfoLocal).date()\r\n                == effective_datetime.date()\r\n                and (\r\n                    transaction_codes := posting_instruction.instruction_details.get(\r\n                        \"transaction_code\"\r\n                    )\r\n                )\r\n            ):\r\n                for transaction_code in map(\r\n                    str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)\r\n                ):\r\n                    if Decimal(debit_daily_limit.get(transaction_code, -1)) < 0:\r\n                        continue\r\n                    debit_address = f\"{LIMIT_TYPE_DAILY_DEBIT}_{transaction_code}\"\r\n                    tracking_daily_limit_posting_instructions.append(\r\n                        _get_tracking_limit_instruction(\r\n                            vault=vault,\r\n                            amount=amount,\r\n                            limit_address=debit_address,\r\n                            event=EVENT_RELEASE_DEBIT_DAILY_LIMIT,\r\n                            is_reversing_limit=True,\r\n                        )\r\n                    )\r\n\r\n            # Track the amount of credit limit\r\n            elif (\r\n                posting_instruction.type in CREDIT_CHECKING_LIMIT_TYPES\r\n                and (\r\n                    transaction_codes := posting_instruction.instruction_details.get(\r\n                        \"transaction_code\"\r\n                    )\r\n                )\r\n            ) or (\r\n                posting_instruction.type is PostingInstructionType.SETTLEMENT\r\n                and (\r\n                    transaction_codes := _get_original_posting_transaction_codes(\r\n                        posting_instruction=posting_instruction,\r\n                        client_transactions=client_transactions,\r\n                        original_posting_type=PostingInstructionType.INBOUND_AUTHORISATION,\r\n                        effective_datetime=effective_datetime,\r\n                    )\r\n                )\r\n            ):\r\n                for transaction_code in map(\r\n                    str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)\r\n                ):\r\n                    if Decimal(credit_daily_limit.get(transaction_code, -1)) < 0:\r\n                        continue\r\n                    credit_address = f\"{LIMIT_TYPE_DAILY_CREDIT}_{transaction_code}\"\r\n                    tracking_daily_limit_posting_instructions.append(\r\n                        _get_tracking_limit_instruction(\r\n                            vault=vault,\r\n                            amount=amount,\r\n                            limit_address=credit_address,\r\n                            event=EVENT_TRACK_CREDIT_DAILY_LIMIT,\r\n                        )\r\n                    )\r\n\r\n        # Debit posting\r\n        elif amount < 0:\r\n            # Revert the amount of credit limit if the posting is released within a day\r\n            if (\r\n                posting_instruction.type\r\n                in [PostingInstructionType.RELEASE, PostingInstructionType.SETTLEMENT]\r\n                and (\r\n                    transaction_codes := _get_original_posting_transaction_codes(\r\n                        posting_instruction=posting_instruction,\r\n                        client_transactions=client_transactions,\r\n                        original_posting_type=PostingInstructionType.INBOUND_AUTHORISATION,\r\n                        effective_datetime=effective_datetime,\r\n                    )\r\n                )\r\n            ) or (\r\n                posting_instruction.type is PostingInstructionType.OUTBOUND_HARD_SETTLEMENT\r\n                and posting_instruction.instruction_details.get(\"rtf_posting_type\")\r\n                == RTF_POSTING_TYPE_REVERSAL\r\n                and (\r\n                    transmission_datetime := posting_instruction.instruction_details.get(\r\n                        \"transmission_datetime\"\r\n                    )\r\n                )\r\n                and parse(transmission_datetime).astimezone(ZoneInfoLocal).date()\r\n                == effective_datetime.date()\r\n                and (\r\n                    transaction_codes := posting_instruction.instruction_details.get(\r\n                        \"transaction_code\"\r\n                    )\r\n                )\r\n            ):\r\n                for transaction_code in map(\r\n                    str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)\r\n                ):\r\n                    if Decimal(credit_daily_limit.get(transaction_code, -1)) < 0:\r\n                        continue\r\n                    credit_address = f\"{LIMIT_TYPE_DAILY_CREDIT}_{transaction_code}\"\r\n                    tracking_daily_limit_posting_instructions.append(\r\n                        _get_tracking_limit_instruction(\r\n                            vault=vault,\r\n                            amount=amount,\r\n                            limit_address=credit_address,\r\n                            event=EVENT_RELEASE_CREDIT_DAILY_LIMIT,\r\n                            is_reversing_limit=True,\r\n                        )\r\n                    )\r\n\r\n            # Track the amount of debit limit\r\n            elif (\r\n                posting_instruction.type in DEBIT_CHECKING_LIMIT_TYPES\r\n                and (\r\n                    transaction_codes := posting_instruction.instruction_details.get(\r\n                        \"transaction_code\"\r\n                    )\r\n                )\r\n                or (\r\n                    posting_instruction.type is PostingInstructionType.SETTLEMENT\r\n                    and (\r\n                        transaction_codes := _get_original_posting_transaction_codes(\r\n                            posting_instruction=posting_instruction,\r\n                            client_transactions=client_transactions,\r\n                            original_posting_type=PostingInstructionType.OUTBOUND_AUTHORISATION,\r\n                            effective_datetime=effective_datetime,\r\n                        )\r\n                    )\r\n                )\r\n            ):\r\n                for transaction_code in map(\r\n                    str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)\r\n                ):\r\n                    if Decimal(debit_daily_limit.get(transaction_code, -1)) < 0:\r\n                        continue\r\n                    debit_address = f\"{LIMIT_TYPE_DAILY_DEBIT}_{transaction_code}\"\r\n                    tracking_daily_limit_posting_instructions.append(\r\n                        _get_tracking_limit_instruction(\r\n                            vault=vault,\r\n                            amount=amount,\r\n                            limit_address=debit_address,\r\n                            event=EVENT_TRACK_DEBIT_DAILY_LIMIT,\r\n                        )\r\n                    )\r\n\r\n    return tracking_daily_limit_posting_instructions\r\n\r\n\r\ndef _get_tracking_monthly_limit_instructions(\r\n    vault,\r\n    *,\r\n    posting_instructions: list[PostingInstruction],\r\n    client_transactions: dict[str, ClientTransaction],\r\n    effective_datetime: datetime,\r\n) -> list[PostingInstruction]:\r\n    \"\"\"Track monthly limit for all posting instructions\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param client_transactions: The dictionary of client transaction in hook arguments\r\n    :type client_transactions: dict[str, ClientTransaction]\r\n    :param effective_datetime: The effective datetime of the posting batch\r\n    :type effective_datetime: datetime\r\n    :return: List of posting instructions for tracking monthly limit\r\n    :rtype: list[PostingInstruction]\r\n    \"\"\"\r\n    tracking_monthly_limit_posting_instructions = []\r\n    kyc_flag = _get_account_kyc(vault)\r\n    authentication_type = _get_account_authentication_method()\r\n    debit_monthly_limit = _get_debit_monthly_limit(vault)[authentication_type][kyc_flag]\r\n\r\n    for posting_instruction in posting_instructions:\r\n        # Revert the amount of debit limit if the posting is released within a month\r\n        if (amount := _get_posting_amount(vault, posting_instruction)) > 0 and (\r\n            (\r\n                # Handle `RELEASE` and `SETTLEMENT` posting\r\n                posting_instruction.type\r\n                in [PostingInstructionType.RELEASE, PostingInstructionType.SETTLEMENT]\r\n                and (\r\n                    transaction_codes := _get_original_posting_transaction_codes(\r\n                        posting_instruction=posting_instruction,\r\n                        client_transactions=client_transactions,\r\n                        original_posting_type=PostingInstructionType.OUTBOUND_AUTHORISATION,\r\n                        effective_datetime=effective_datetime,\r\n                        is_month_limit=True,\r\n                    )\r\n                )\r\n            )\r\n            or (\r\n                # Handle _REVERSAL_ posting\r\n                posting_instruction.type is PostingInstructionType.INBOUND_HARD_SETTLEMENT\r\n                and posting_instruction.instruction_details.get(\"rtf_posting_type\")\r\n                == RTF_POSTING_TYPE_REVERSAL\r\n                and (\r\n                    transmission_datetime := posting_instruction.instruction_details.get(\r\n                        \"transmission_datetime\"\r\n                    )\r\n                )\r\n                and parse(transmission_datetime).astimezone(ZoneInfoLocal).date().replace(day=1)\r\n                == effective_datetime.date().replace(day=1)\r\n                and (\r\n                    transaction_codes := posting_instruction.instruction_details.get(\r\n                        \"transaction_code\"\r\n                    )\r\n                )\r\n            )\r\n        ):\r\n            for transaction_code in map(\r\n                str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)\r\n            ):\r\n                if Decimal(debit_monthly_limit.get(transaction_code, -1)) < 0:\r\n                    continue\r\n                debit_address = f\"{LIMIT_TYPE_MONTHLY_DEBIT}_{transaction_code}\"\r\n                tracking_monthly_limit_posting_instructions.append(\r\n                    _get_tracking_limit_instruction(\r\n                        vault=vault,\r\n                        amount=amount,\r\n                        limit_address=debit_address,\r\n                        event=EVENT_RELEASE_DEBIT_MONTHLY_LIMIT,\r\n                        is_reversing_limit=True,\r\n                    )\r\n                )\r\n\r\n        # Track the amount of debit limit\r\n        elif amount < 0 and (\r\n            (\r\n                posting_instruction.type in DEBIT_CHECKING_LIMIT_TYPES\r\n                and (\r\n                    transaction_codes := posting_instruction.instruction_details.get(\r\n                        \"transaction_code\"\r\n                    )\r\n                )\r\n            )\r\n            or (\r\n                posting_instruction.type is PostingInstructionType.SETTLEMENT\r\n                and (\r\n                    transaction_codes := _get_original_posting_transaction_codes(\r\n                        posting_instruction=posting_instruction,\r\n                        client_transactions=client_transactions,\r\n                        original_posting_type=PostingInstructionType.OUTBOUND_AUTHORISATION,\r\n                        effective_datetime=effective_datetime,\r\n                        is_month_limit=True,\r\n                    )\r\n                )\r\n            )\r\n        ):\r\n            for transaction_code in map(\r\n                str.strip, transaction_codes.split(TRANSACTION_CODE_SEPARATOR)\r\n            ):\r\n                if Decimal(debit_monthly_limit.get(transaction_code, -1)) < 0:\r\n                    continue\r\n                debit_address = f\"{LIMIT_TYPE_MONTHLY_DEBIT}_{transaction_code}\"\r\n                tracking_monthly_limit_posting_instructions.append(\r\n                    _get_tracking_limit_instruction(\r\n                        vault=vault,\r\n                        amount=amount,\r\n                        limit_address=debit_address,\r\n                        event=EVENT_TRACK_DEBIT_MONTHLY_LIMIT,\r\n                    )\r\n                )\r\n\r\n    return tracking_monthly_limit_posting_instructions\r\n\r\n\r\ndef _get_tracking_limit_instruction(\r\n    vault,\r\n    amount: Decimal,\r\n    limit_address: str,\r\n    event: str,\r\n    is_reversing_limit: Optional[bool] = False,\r\n) -> CustomInstruction:\r\n    \"\"\"Get tracking limit posting instruction\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param amount: Amount to track limit\r\n    :type amount: Decimal\r\n    :param address: Address to track limit\r\n    :type address: str\r\n    :param event: Event to track limit\r\n    :type event: str\r\n    :param is_reversing_limit: Whether to revert limit, defaults to False\r\n    :type is_reversing_limit: Optional[bool]\r\n    :return: Posting instruction for tracking limit\r\n    :rtype: PostingInstruction\r\n    \"\"\"\r\n\r\n    from_account_address, to_account_address = (\r\n        (ADDRESS_INTERNAL_CONTRA, limit_address)\r\n        if not is_reversing_limit\r\n        else (limit_address, ADDRESS_INTERNAL_CONTRA)\r\n    )\r\n\r\n    return _move_funds_between_vault_accounts(\r\n        vault,\r\n        amount=abs(amount),\r\n        from_account_address=from_account_address,\r\n        to_account_address=to_account_address,\r\n        event=event,\r\n    )\r\n\r\n\r\n# endregion Post posting hook helpers\r\n\r\n# region Derived parameter helpers\r\n\r\n\r\ndef _get_remaining_limits(\r\n    vault, *, effective_datetime: datetime\r\n) -> tuple[dict[str, dict[str, dict[str, str]]], ...]:\r\n    \"\"\"Get remaining limits for daily and monthly transaction\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param effective_datetime: The effective datetime to query remaining limits\r\n    :type effective_datetime: datetime\r\n    :return: Remaining limits for daily and monthly transaction\r\n    :rtype: Tuple\r\n    \"\"\"\r\n\r\n    kyc_type = _get_account_kyc(vault)\r\n    authentication_type = _get_account_authentication_method()\r\n    credit_daily_limit = _get_credit_daily_limit(vault)[authentication_type][kyc_type]\r\n    debit_daily_limit = _get_debit_daily_limit(vault)[authentication_type][kyc_type]\r\n\r\n    debit_monthly_limit = _get_debit_monthly_limit(vault)[authentication_type][kyc_type]\r\n\r\n    def _get_remaining_limit(\r\n        address: str, limit: Decimal, limit_tracking_fetcher_id: str, start_timestamp: datetime\r\n    ) -> Decimal:\r\n        if limit < 0:\r\n            return Decimal(-1)\r\n\r\n        delta_balance = _get_balance_sum(\r\n            vault=vault, addresses=[address], fetcher_id=BOF_ID_EFFECTIVE_DATETIME_BALANCE\r\n        ) - _get_balance_sum(\r\n            vault=vault,\r\n            addresses=[address],\r\n            fetcher_id=limit_tracking_fetcher_id,\r\n            timestamp=start_timestamp,\r\n        )\r\n\r\n        remaining_limit = limit - delta_balance\r\n        return max(remaining_limit, Decimal(0))\r\n\r\n    return (\r\n        {\r\n            authentication_type: {\r\n                kyc_type: {\r\n                    transaction_code: str(\r\n                        _get_remaining_limit(\r\n                            get_address_by_transaction_code(transaction_code),\r\n                            Decimal(limit),\r\n                            fetcher_id,\r\n                            get_start_datetime(effective_datetime) - relativedelta(microseconds=1),\r\n                        )\r\n                    )\r\n                    for transaction_code, limit in transaction_code_to_limit.items()\r\n                }\r\n            }\r\n        }\r\n        for (\r\n            transaction_code_to_limit,\r\n            get_address_by_transaction_code,\r\n            fetcher_id,\r\n            get_start_datetime,\r\n        ) in (\r\n            (\r\n                credit_daily_limit,\r\n                lambda transaction_code: f\"{LIMIT_TYPE_DAILY_CREDIT}_{transaction_code}\",\r\n                BIF_ID_ONE_DAY_FOR_DAILY_LIMIT_TRACKING,\r\n                _get_beginning_of_day,\r\n            ),\r\n            (\r\n                debit_daily_limit,\r\n                lambda transaction_code: f\"{LIMIT_TYPE_DAILY_DEBIT}_{transaction_code}\",\r\n                BIF_ID_ONE_DAY_FOR_DAILY_LIMIT_TRACKING,\r\n                _get_beginning_of_day,\r\n            ),\r\n            (\r\n                debit_monthly_limit,\r\n                lambda transaction_code: f\"{LIMIT_TYPE_MONTHLY_DEBIT}_{transaction_code}\",\r\n                BIF_ID_BEFORE_BEGINNING_OF_MONTH_FOR_MONTHLY_LIMIT_TRACKING,\r\n                _get_beginning_of_month,\r\n            ),\r\n        )\r\n    )\r\n\r\n\r\n# endregion Derived parameter helpers\r\n\r\n\r\n# region Deactivation hook helpers\r\n\r\n\r\ndef _reverse_tracking_limits(vault) -> list[CustomInstruction]:\r\n    \"\"\"Reverse tracking limits\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :return: List of posting instructions for reversing tracking limits\r\n    :rtype: list[PostingInstruction]\r\n    \"\"\"\r\n\r\n    debit_daily_limit = _get_debit_daily_limit(vault)\r\n    debit_daily_transaction_codes = set(debit_daily_limit[SOFT_OTP][TYPE_EKYC]) | set(\r\n        debit_daily_limit[SOFT_OTP][TYPE_VKYC]\r\n    )\r\n    tracking_addresses = {\r\n        f\"{LIMIT_TYPE_DAILY_DEBIT}_{transaction_code}\"\r\n        for transaction_code in debit_daily_transaction_codes\r\n    }\r\n\r\n    credit_daily_limit = _get_credit_daily_limit(vault)\r\n    credit_daily_transaction_codes = set(credit_daily_limit[SOFT_OTP][TYPE_EKYC]) | set(\r\n        credit_daily_limit[SOFT_OTP][TYPE_VKYC]\r\n    )\r\n    tracking_addresses |= {\r\n        f\"{LIMIT_TYPE_DAILY_CREDIT}_{transaction_code}\"\r\n        for transaction_code in credit_daily_transaction_codes\r\n    }\r\n\r\n    debit_monthly_limit = _get_debit_monthly_limit(vault)\r\n    debit_monthly_transaction_codes = set(debit_monthly_limit[SOFT_OTP][TYPE_EKYC]) | set(\r\n        debit_monthly_limit[SOFT_OTP][TYPE_VKYC]\r\n    )\r\n    tracking_addresses |= {\r\n        f\"{LIMIT_TYPE_MONTHLY_DEBIT}_{transaction_code}\"\r\n        for transaction_code in debit_monthly_transaction_codes\r\n    }\r\n\r\n    reverse_tracking_limits_instructions = []\r\n    for address in sorted(tracking_addresses):\r\n        limit_tracking_balance = _get_balance_sum(\r\n            vault, addresses=[address], fetcher_id=BOF_ID_LIVE_BALANCE\r\n        )\r\n\r\n        if limit_tracking_balance > 0:\r\n            reverse_tracking_limits_instructions.append(\r\n                _get_tracking_limit_instruction(\r\n                    vault=vault,\r\n                    amount=limit_tracking_balance,\r\n                    limit_address=address,\r\n                    event=EVENT_REVERSE_TRACKING_BALANCES_ON_CLOSING,\r\n                    is_reversing_limit=True,\r\n                )\r\n            )\r\n    return reverse_tracking_limits_instructions\r\n\r\n\r\ndef _reverse_remaining_interest_accrual(\r\n    vault, *, balance_default_dict: BalanceDefaultDict\r\n) -> list[CustomInstruction]:\r\n    \"\"\"Reverse remaining amount in interest accrual address\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param balance_default_dict: The balance_default_dict used to get interest amount\r\n    :type balance_default_dict: BalanceDefaultDict\r\n    :return: List of posting instructions for reversing remain amount in interest accrual address\r\n    :rtype: list[PostingInstruction]\r\n    \"\"\"\r\n    interest_accrual_address_balance = _get_balance_sum(\r\n        vault, addresses=[ADDRESS_ACCRUAL_INTEREST], balances_default_dict=balance_default_dict\r\n    )\r\n    if interest_accrual_address_balance <= 0 or interest_accrual_address_balance > 1:\r\n        return []\r\n\r\n    posting_instructions = [\r\n        _move_funds_between_vault_accounts(\r\n            vault=vault,\r\n            amount=interest_accrual_address_balance,\r\n            from_account_address=ADDRESS_ACCRUAL_INTEREST,\r\n            to_account_address=ADDRESS_INTERNAL_CONTRA,\r\n            instruction_details={\"description\": \"Revert of remaining accrual interest\"},\r\n            event=EVENT_REVERT_ACCRUAL_INTEREST,\r\n        )\r\n    ]\r\n\r\n    return posting_instructions\r\n\r\n\r\n# endregion Deactivation hook helpers\r\n\r\n# region General helpers\r\n\r\n\r\ndef _get_resolved_parameter(\r\n    vault,\r\n    name: str,\r\n    timestamp: Optional[datetime] = None,\r\n    is_json: bool = False,\r\n    is_boolean: bool = False,\r\n    is_union: bool = False,\r\n    is_optional: bool = False,\r\n) -> Any:\r\n    \"\"\"\r\n    Get the parameter value for a given parameter\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param name: name of the parameter to retrieve\r\n    :param at: datetime, time at which to retrieve the parameter value. If not specified the\r\n        latest value is retrieved\r\n    :param is_json: if true `json_loads` is called on the retrieved parameter value\r\n    :param is_boolean: if true `str_to_bool` is called on the retrieved parameter value\r\n    :param union: if True parameter will be treated as a UnionItem\r\n    :param optional: if true we treat the parameter as optional\r\n    :return:\r\n    \"\"\"\r\n\r\n    def _get_parameter(\r\n        vault, name: str, timestamp: Optional[datetime] = None\r\n    ) -> Union[Decimal, str, datetime, OptionalValue, UnionItemValue, int]:\r\n        if timestamp is None:\r\n            return vault.get_parameter_timeseries(name=name).latest()\r\n        return vault.get_parameter_timeseries(name=name).at(timestamp=timestamp)\r\n\r\n    parameter = _get_parameter(vault, name, timestamp)\r\n\r\n    return _get_parameter_value(\r\n        parameter=parameter,\r\n        is_json=is_json,\r\n        is_boolean=is_boolean,\r\n        union=is_union,\r\n        optional=is_optional,\r\n    )\r\n\r\n\r\ndef _get_parameter_value(\r\n    parameter: Union[Decimal, str, datetime, OptionalValue, UnionItemValue, int],\r\n    is_json: bool = False,\r\n    is_boolean: bool = False,\r\n    union: bool = False,\r\n    optional: bool = False,\r\n):\r\n    if optional:\r\n        parameter = parameter.value if parameter.is_set() else None\r\n\r\n    if union and parameter is not None:\r\n        parameter = parameter.key\r\n\r\n    if is_boolean and parameter is not None:\r\n        return _str_to_bool(parameter)\r\n\r\n    if is_json and parameter is not None:\r\n        parameter = loads(parameter)\r\n\r\n    return parameter\r\n\r\n\r\ndef _str_to_bool(string: str) -> bool:\r\n    \"\"\"Convert a string true to bool True, default value of False.\r\n\r\n    :param string: The string to convert\r\n    :type string: str\r\n    :return: The converted bool value\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    return str(string).lower() == \"true\"\r\n\r\n\r\ndef _get_balance_sum(\r\n    vault,\r\n    *,\r\n    addresses: list[str],\r\n    balances_default_dict: Optional[BalanceDefaultDict] = None,\r\n    fetcher_id: Optional[str] = None,\r\n    timestamp: Optional[datetime] = None,\r\n    denomination: Optional[str] = None,\r\n    phase: Phase = Phase.COMMITTED,\r\n) -> Decimal:\r\n    \"\"\"\r\n    Sum balances for list of given addresses.\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param addresses: List of addresses to sum balance\r\n    :type addresses: list[str]\r\n    :param balance_default_dict: The balance_default_dict to retrieve balance, defaults to None\r\n    :type balance_default_dict: Optional[BalanceDefaultDict], optional\r\n    :param fetcher_id: The fetcher_id to retrieve desired balance, defaults to None\r\n    :type fetcher_id: Optional[str], optional\r\n    :param timestamp: The timestamp to retrieve desired balance, only use if input fetcher_id is\r\n        balance interval fetcher id, defaults to None\r\n    :type timestamp: Optional[datetime], optional\r\n    :param denomination: The currency of account, defaults to None\r\n    :type denomination: Optional[str], optional\r\n    :param phase: Phase of the addresses, defaults to Phase.COMMITTED\r\n    :type phase: Optional[str], optional\r\n    :return: The sum amount of the addresses\r\n    :rtype: Decimal\r\n    \"\"\"\r\n\r\n    balances_default_dict = (\r\n        balances_default_dict\r\n        if balances_default_dict is not None\r\n        else (\r\n            _get_observation_balance_default_dict(vault, balance_observation_fetcher_id=fetcher_id)\r\n            if fetcher_id in bof_fetcher_ids\r\n            else _get_balance_default_dict_from_mapping(\r\n                vault.get_balances_timeseries(fetcher_id=fetcher_id), effective_datetime=timestamp\r\n            )\r\n        )\r\n    )\r\n\r\n    denomination = denomination or _get_resolved_parameter(vault, \"denomination\")\r\n\r\n    return Decimal(\r\n        sum(\r\n            balances_default_dict[\r\n                BalanceCoordinate(address, DEFAULT_ASSET, denomination, phase)\r\n            ].net\r\n            for address in addresses\r\n        )\r\n    )\r\n\r\n\r\ndef _get_balance_default_dict_from_mapping(\r\n    mapping: Mapping[BalanceCoordinate, BalanceTimeseries],\r\n    effective_datetime: Optional[datetime] = None,\r\n) -> BalanceDefaultDict:\r\n    \"\"\"\r\n    Converts the balances mapping fetched from `vault.get_balances_timeseries()` into a\r\n    `BalanceDefaultDict`, taking either the latest or `at_datetime` entry of the timeseries\r\n\r\n    :param mapping: map of balance coordinates to balance timeseries\r\n    :param effective_datetime: if provided, the timeseries value at that timestamp will be used,\r\n        otherwise the latest value will be used\r\n    :return: BalanceDefaultDict from the timeseries mapping\r\n    \"\"\"\r\n\r\n    balance_mapping: dict[BalanceCoordinate, Balance] = {\r\n        coordinate: (\r\n            timeseries.at(at_datetime=effective_datetime)\r\n            if effective_datetime\r\n            else timeseries.latest()\r\n        )\r\n        for coordinate, timeseries in mapping.items()\r\n    }\r\n    return BalanceDefaultDict(mapping=balance_mapping)\r\n\r\n\r\ndef _get_available_balance(vault, *, balance_default_dict: BalanceDefaultDict) -> Decimal:\r\n    \"\"\"Get the available balance of the account\r\n\r\n    :param vault: Vault object\r\n    :type vault:\r\n    :param balance_default_dict: The balance_default_dict to retrieve balance\r\n    :type balance_default_dict: BalanceDefaultDict\r\n    :return: The available balance of the account. If the available balance is negative, return 0\r\n    :rtype: Decimal\r\n    \"\"\"\r\n\r\n    minimum_balance = Decimal(_get_resolved_parameter(vault, \"minimum_balance\"))\r\n\r\n    available_balance = (\r\n        sum(\r\n            _get_balance_sum(\r\n                vault=vault,\r\n                addresses=[DEFAULT_ADDRESS],\r\n                balances_default_dict=balance_default_dict,\r\n                phase=phase,\r\n            )\r\n            for phase in [Phase.COMMITTED, Phase.PENDING_OUT]\r\n        )\r\n        - minimum_balance\r\n    )\r\n\r\n    return max(available_balance, Decimal(0))\r\n\r\n\r\ndef _round_decimal(amount: Decimal, decimal_places: int, rounding: str = ROUND_HALF_UP) -> Decimal:\r\n    \"\"\"Round an amount to specified number of decimal places\r\n\r\n    :param amount: Amount to round\r\n    :type amount: Decimal\r\n    :param decimal_places: Number of decimal places to round to\r\n    :type decimal_places: int\r\n    :param rounding: The type of rounding strategy to use, defaults to ROUND_HALF_UP\r\n    :type rounding: str, optional\r\n    :return: Rounded amount\r\n    :rtype: Decimal\r\n    \"\"\"\r\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\r\n\r\n\r\ndef _move_funds_between_vault_accounts(\r\n    vault,\r\n    amount: Decimal,\r\n    event: str,\r\n    denomination: Optional[str] = None,\r\n    from_account_id: Optional[str] = None,\r\n    from_account_address: Optional[str] = DEFAULT_ADDRESS,\r\n    to_account_id: Optional[str] = None,\r\n    to_account_address: Optional[str] = DEFAULT_ADDRESS,\r\n    instruction_details: Optional[dict[str, str]] = None,\r\n    asset: Optional[str] = DEFAULT_ASSET,\r\n    transaction_code: Optional[TransactionCode] = None,\r\n    override_all_restrictions: Optional[bool] = True,\r\n) -> CustomInstruction:\r\n    \"\"\"Create a custom instruction to move funds between vault accounts.\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param amount: Amount to transfer\r\n    :type amount: Decimal\r\n    :param event: Brief description of the event\r\n    :type event: Optional[str]\r\n    :param denomination: The currency of the posting, defaults to None\r\n    :type denomination: Optional[str], optional\r\n    :param from_account_id: Debit account id, defaults to None\r\n    :type from_account_id: Optional[str], optional\r\n    :param from_account_address: Address of debit account id, defaults to DEFAULT_ADDRESS\r\n    :type from_account_address: Optional[str], optional\r\n    :param to_account_id: Debit account id, defaults to None\r\n    :type to_account_id: Optional[str], optional\r\n    :param to_account_address: Address of credit account id, defaults to DEFAULT_ADDRESS\r\n    :type to_account_address: Optional[str], optional\r\n    :param instruction_details: Meta date which needed for the posting, defaults to None\r\n    :type instruction_details: Optional[dict[str, str]], optional\r\n    :param asset: Asset type of the balance in this posting, defaults to DEFAULT_ASSET\r\n    :type asset: Optional[str], optional\r\n    :param override_all_restrictions: whether to bypass all restriction, defaults to True\r\n    :type override_all_restrictions: Optional[bool], optional\r\n    :return: CustomInstruction object\r\n    :rtype: CustomInstruction\r\n    \"\"\"\r\n    denomination = denomination or _get_resolved_parameter(vault, \"denomination\")\r\n    from_account_id = from_account_id or vault.account_id\r\n    to_account_id = to_account_id or vault.account_id\r\n\r\n    postings = [\r\n        Posting(\r\n            credit=False,\r\n            amount=amount,\r\n            denomination=denomination,\r\n            account_id=from_account_id,\r\n            account_address=from_account_address,\r\n            asset=asset,\r\n            phase=Phase.COMMITTED,\r\n        ),\r\n        Posting(\r\n            credit=True,\r\n            amount=amount,\r\n            denomination=denomination,\r\n            account_id=to_account_id,\r\n            account_address=to_account_address,\r\n            asset=asset,\r\n            phase=Phase.COMMITTED,\r\n        ),\r\n    ]\r\n\r\n    instruction_details = instruction_details or {}\r\n    instruction_details[\"event\"] = event\r\n\r\n    return CustomInstruction(\r\n        postings=postings,\r\n        instruction_details=instruction_details,\r\n        transaction_code=transaction_code,\r\n        override_all_restrictions=override_all_restrictions,\r\n    )\r\n\r\n\r\ndef _update_balance_default_dict_by_postings(\r\n    *,\r\n    account_id: str,\r\n    posting_instructions: list[PostingInstruction],\r\n    balance_default_dict: Optional[BalanceDefaultDict] = None,\r\n) -> BalanceDefaultDict:\r\n    \"\"\"Update the balance for an account based on new postings that are made.\r\n\r\n    This method assumes phases can be collapsed to handle scenarios where PostingInstruction phase\r\n    is not defined.\r\n\r\n    :param account_id: account ID in question.\r\n    :type account_id: str\r\n    :param postings: new postings to adjust balance with.\r\n    :type postings: list[PostingInstruction]\r\n    :param balance_default_dict: the balance to update, if not provided, an empty balance will be\r\n        used, defaults to None\r\n    :type balance_default_dict: Optional[BalanceDefaultDict], optional\r\n    :return: Updated balance.\r\n    :rtype: BalanceDefaultDict\r\n    \"\"\"\r\n\r\n    sum_balance_default_dict = balance_default_dict or BalanceDefaultDict()\r\n\r\n    # TODO: The current vault instance (4.5.3) requires tside to get balance default dict from\r\n    # internal posting. Will need to check this in instance  5.0.0\r\n    # TODO: Also The current vault instance (4.5.3) does not support using sum for balance\r\n    # aggregations. Will need to check this in instance  4.6.0\r\n\r\n    for posting_instruction in posting_instructions:\r\n        sum_balance_default_dict += posting_instruction.balances(account_id=account_id, tside=tside)\r\n    return sum_balance_default_dict\r\n\r\n\r\ndef _get_observation_balance_default_dict(\r\n    vault, balance_observation_fetcher_id: str\r\n) -> BalanceDefaultDict:\r\n    \"\"\"Get the balance_default_dict from the balance_observation_fetcher_id\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param fetcher_id: The fetcher_id to retrieve desired balance default dict\r\n    :type fetcher_id: str\r\n    :return: The balance_default_dict\r\n    :rtype: BalanceDefaultDict\r\n    \"\"\"\r\n\r\n    if balance_observation_fetcher_id not in bof_fetcher_ids:\r\n        return BalanceDefaultDict()\r\n\r\n    return vault.get_balances_observation(fetcher_id=balance_observation_fetcher_id).balances\r\n\r\n\r\ndef _get_balance_default_dict_by_datetime(\r\n    vault, *, balance_interval_fetcher_id: str, effective_datetime: Optional[datetime] = None\r\n) -> BalanceDefaultDict:\r\n    \"\"\"Get the balance_default_dict from the bif_fetcher_id at provided datetime or latest\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param balance_interval_fetcher_id: The fetcher_id to retrieve desired balance default dict\r\n    :type balance_interval_fetcher_id: str\r\n    :param effective_datetime: The datetime to retrieve desired balance default dict\r\n    :type effective_datetime: datetime\r\n    :return: The balance_default_dict\r\n    :rtype: BalanceDefaultDict\r\n    \"\"\"\r\n\r\n    if balance_interval_fetcher_id not in bif_fetcher_id:\r\n        return BalanceDefaultDict()\r\n\r\n    balance_timeseries = vault.get_balances_timeseries(fetcher_id=balance_interval_fetcher_id)\r\n    balance_mapping: dict[BalanceCoordinate, Balance] = {\r\n        coordinate: (\r\n            timeseries.at(at_datetime=effective_datetime.astimezone(ZoneInfoUtc))\r\n            if effective_datetime\r\n            else timeseries.latest()\r\n        )\r\n        for coordinate, timeseries in balance_timeseries.items()\r\n    }\r\n    return BalanceDefaultDict(mapping=balance_mapping)\r\n\r\n\r\ndef _batch_details_to_bool(\r\n    posting_instructions: list[PostingInstruction], batch_details_key: str\r\n) -> bool:\r\n    \"\"\"Retrieve posting indicator from posting instruction batch details\r\n\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param batch_details_key: The indicator in batch details\r\n    :type batch_details_key: str\r\n    :return: The bool value of the indicator\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    if batch_details := posting_instructions[0].batch_details:\r\n        return _str_to_bool(batch_details.get(batch_details_key, \"false\"))\r\n    return False\r\n\r\n\r\ndef _instruction_details_to_bool(\r\n    posting_instruction: PostingInstruction, instruction_details_key: str\r\n) -> bool:\r\n    \"\"\"Retrieve posting indicator from posting instruction details\r\n\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param batch_details_key: The indicator in batch details\r\n    :type batch_details_key: str\r\n    :return: The bool value of the indicator\r\n    :rtype: bool\r\n    \"\"\"\r\n\r\n    return _str_to_bool(\r\n        posting_instruction.instruction_details.get(instruction_details_key, \"false\")\r\n    )\r\n\r\n\r\ndef _get_posting_amount(vault, posting_instruction: PostingInstruction) -> Decimal:\r\n    \"\"\"Get the actual posting amount that affect on `DEFAULT` address which can be negative or\r\n    positive\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param posting: The posting instruction to retrieve amount\r\n    :type posting: PostingInstruction\r\n    :param denomination: The currency of account, defaults to None\r\n    :type denomination: Optional[str]\r\n    :return: The posting amount\r\n    :rtype: Decimal\r\n    \"\"\"\r\n\r\n    return sum(\r\n        _get_balance_sum(\r\n            vault,\r\n            addresses=[DEFAULT_ADDRESS],\r\n            balances_default_dict=posting_instruction.balances(\r\n                account_id=vault.account_id, tside=tside\r\n            ),\r\n            phase=phase,\r\n        )\r\n        for phase in [Phase.COMMITTED, Phase.PENDING_OUT, Phase.PENDING_IN]\r\n    )\r\n\r\n\r\ndef _get_posting_instructions_directives(\r\n    vault,\r\n    *,\r\n    posting_instructions: list[CustomInstruction],\r\n    value_datetime: datetime,\r\n    event: str,\r\n    client_batch_id: Optional[str] = None,\r\n    batch_details: dict[str, str] = None,\r\n) -> list[PostingInstructionsDirective]:\r\n    \"\"\"Get the posting instructions directives from posting instructions\r\n\r\n    :param posting_instructions: The list of input posting instructions\r\n    :type posting_instructions: list[PostingInstruction]\r\n    :param value_datetime: The datetime to instruct posting instructions directives\r\n    :type value_datetime: datetime\r\n    :param event: The event to instruct posting instructions directives\r\n    :type event: str\r\n    :return: The posting instructions directives\r\n    :rtype: list[PostingInstructionsDirective]\r\n    \"\"\"\r\n\r\n    if not posting_instructions:\r\n        return []\r\n    batch_details = batch_details or {}\r\n    if event in EVENT_TRANSACTION_TYPE_NAME:\r\n        trans_type_name = EVENT_TRANSACTION_TYPE_NAME.get(event, None)\r\n        if trans_type_name:\r\n            batch_details[TRANS_TYPE_NAME] = trans_type_name\r\n            for posting_instruction in posting_instructions:\r\n                posting_instruction.instruction_details[TRANS_TYPE_NAME] = trans_type_name\r\n\r\n    hook_execution_id = vault.get_hook_execution_id()\r\n    return [\r\n        PostingInstructionsDirective(\r\n            posting_instructions=posting_instructions,\r\n            value_datetime=value_datetime.astimezone(ZoneInfoUtc),\r\n            client_batch_id=client_batch_id if client_batch_id else f\"{event}_{hook_execution_id}\",\r\n            batch_details=batch_details if batch_details else None,\r\n        )\r\n    ]\r\n\r\n\r\ndef _get_beginning_of_day(input_datetime: datetime) -> datetime:\r\n    \"\"\"Get the beginning of the day of the input datetime\r\n\r\n    :param input_datetime: The input datetime\r\n    :type input_datetime: datetime\r\n    :return: The beginning of the day of the input datetime\r\n    :rtype: datetime\r\n    \"\"\"\r\n\r\n    return (\r\n        input_datetime.astimezone(ZoneInfoLocal)\r\n        .replace(hour=0, minute=0, second=0, microsecond=0)\r\n        .astimezone(ZoneInfoUtc)\r\n    )\r\n\r\n\r\ndef _get_beginning_of_month(input_datetime: datetime) -> datetime:\r\n    \"\"\"Get the beginning of the month of the input datetime\r\n\r\n    :param input_datetime: The input datetime\r\n    :type input_datetime: datetime\r\n    :return: The beginning of the month of the input datetime\r\n    :rtype: datetime\r\n    \"\"\"\r\n\r\n    return (\r\n        input_datetime.astimezone(ZoneInfoLocal)\r\n        .replace(day=1, hour=0, minute=0, second=0, microsecond=0)\r\n        .astimezone(ZoneInfoUtc)\r\n    )\r\n\r\n\r\ndef _is_current_account_status(\r\n    vault, status: str, effective_datetime: Optional[datetime] = None\r\n) -> bool:\r\n    return (\r\n        _get_resolved_parameter(\r\n            vault, \"status\", is_union=True, timestamp=effective_datetime\r\n        ).upper()\r\n        == status.upper()\r\n    )\r\n\r\n\r\ndef _parse_time(string_time: str) -> Optional[tuple[int, int, int]]:\r\n    \"\"\"\r\n    Parse time from string with format \"%H:%M:%S\".\r\n\r\n    :param string_datetime: The input string to be parsed\r\n    :type string_datetime: str\r\n    :return: The parsed time, or None if `string_time` is invalid\r\n    :rtype: Optional[tuple[int, int, int]]\r\n    \"\"\"\r\n\r\n    parsed_time = parse(string_time)\r\n\r\n    return parsed_time.hour, parsed_time.minute, parsed_time.second\r\n\r\n\r\ndef _get_last_execution_datetime(vault, *, event_name: str) -> datetime:\r\n    \"\"\"Get the last execution datetime of the event\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :param event_name: The event name\r\n    :type event_name: str\r\n    :return: The last execution datetime of the event\r\n    :rtype: datetime\r\n    \"\"\"\r\n\r\n    last_execution_datetime = vault.get_last_execution_datetime(event_type=event_name) or datetime(\r\n        1970, 1, 1, 0, 0, 0\r\n    )\r\n\r\n    return last_execution_datetime.astimezone(ZoneInfoLocal)\r\n\r\n\r\ndef _is_on_last_day_of_month(input_datetime: datetime) -> bool:\r\n    \"\"\"Check whether the input datetime is on the last day of the month\r\n\r\n    :param input_datetime: The input datetime\r\n    :type input_datetime: datetime\r\n    :return: True if the input datetime is on the last day of the month, False otherwise\r\n    :rtype: bool\r\n    \"\"\"\r\n    input_datetime = input_datetime.astimezone(ZoneInfoLocal)\r\n    return _is_on_first_day_of_month(input_datetime + relativedelta(days=1))\r\n\r\n\r\ndef _is_on_first_day_of_month(input_datetime: datetime) -> bool:\r\n    \"\"\"Check whether the input datetime is on the first day of the month\r\n\r\n    :param input_datetime: The input datetime\r\n    :type input_datetime: datetime\r\n    :return: True if the input datetime is on the first day of the month, False otherwise\r\n    :rtype: bool\r\n    \"\"\"\r\n    input_datetime = input_datetime.astimezone(ZoneInfoLocal)\r\n    return input_datetime.day == 1\r\n\r\n\r\ndef _get_client_batch_id(account_id: str, event_type: str) -> Optional[str]:\r\n    \"\"\"Get client batch id\r\n\r\n    :param account_id: The account id\r\n    :type account_id: str\r\n    :param event_type: The event type\r\n    :type event_type: str\r\n    :return: The client batch id\r\n    :rtype: Optional[str]\r\n    \"\"\"\r\n    if not all([account_id, event_type]):\r\n        return\r\n\r\n    today_datetime = datetime.now()\r\n    today_timestamp = datetime.timestamp(today_datetime)\r\n\r\n    transaction_type, event_digit = EVENT_SIGNATURE_SET.get(event_type, (\"\", \"\"))\r\n\r\n    return f\"{transaction_type}{account_id[2:]}{int(today_timestamp)}{event_digit}\"\r\n\r\n\r\n# endregion General helpers\r\n\r\n\r\n# region Limit helpers\r\n\r\n\r\ndef _get_account_kyc(vault) -> str:\r\n    \"\"\"Get the kyc flag that currently applied to account\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :return: the flag value\r\n    :rtype: str\r\n    \"\"\"\r\n    if vault.get_flag_timeseries(flag=FLAG_VKYC).latest():\r\n        return TYPE_VKYC\r\n\r\n    return TYPE_EKYC\r\n\r\n\r\ndef _get_account_authentication_method() -> str:\r\n    \"\"\"Get the authentication method that currently applied to account\r\n\r\n    :return: the authentication method\r\n    :rtype: str\r\n    \"\"\"\r\n\r\n    return SOFT_OTP\r\n\r\n\r\ndef _get_credit_daily_limit(vault) -> dict[str, dict[str, dict[str, str]]]:\r\n    \"\"\"Get the set of daily credit limit by transaction code\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :return:  daily credit limit by transaction code\r\n    :rtype: dict[str, str]\r\n    \"\"\"\r\n\r\n    return _get_resolved_parameter(vault, \"credit_daily_limit\", is_json=True)\r\n\r\n\r\ndef _get_debit_daily_limit(vault) -> dict[str, dict[str, dict[str, str]]]:\r\n    \"\"\"Get the set of daily debit limit by transaction code\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :return:  daily debit limit by transaction code\r\n    :rtype: dict[str, str]\r\n    \"\"\"\r\n\r\n    if customer_debit_daily_limit := _get_resolved_parameter(\r\n        vault, \"customer_debit_daily_limit\", is_optional=True\r\n    ):\r\n        return _get_parameter_value(customer_debit_daily_limit, is_json=True)\r\n    return _get_resolved_parameter(vault, \"debit_daily_limit\", is_json=True)\r\n\r\n\r\ndef _get_debit_monthly_limit(vault) -> dict[str, dict[str, Union[str, list[str]]]]:\r\n    \"\"\"Retrieve monthly limit corresponding to flag.\r\n\r\n    :param vault: Vault object\r\n    :type vault: Vault\r\n    :return: monthly limit amount by flag\r\n    :rtype: dict\r\n    \"\"\"\r\n\r\n    return _get_resolved_parameter(vault, \"debit_monthly_limit\", is_json=True)\r\n\r\n\r\n# endregion Limit helpers\r\n\r\n\r\n# region `post_parameter_change_hook`\r\ndef _has_parameter_value_changed(\r\n    parameter_name: str,\r\n    old_parameter_values: dict[\r\n        str, Union[datetime, Decimal, int, OptionalValue, str, UnionItemValue]\r\n    ],\r\n    updated_parameter_values: dict[\r\n        str, Union[datetime, Decimal, int, OptionalValue, str, UnionItemValue]\r\n    ],\r\n) -> bool:\r\n    \"\"\"\r\n    Determines if a parameter has changed. To be used within post-parameter change hook.\r\n\r\n    :param parameter_name: name of the parameter\r\n    :type: parameter_name: str\r\n    :param old_parameter_values: map of parameter name to old parameter value\r\n    :type: old_parameter_values: dict[str, str]\r\n    :param updated_parameter_values: dict[str, str], map of parameter name to new parameter value\r\n    :type updated_parameter_values: dict[str, str]\r\n    :return: bool, True if parameter value has changed, False otherwise,\r\n    :rtype: bool\r\n    \"\"\"\r\n    if parameter_name not in updated_parameter_values:\r\n        return False\r\n\r\n    if old_parameter_values[parameter_name] == updated_parameter_values[parameter_name]:\r\n        return False\r\n\r\n    return True\r\n\r\n\r\n# endregion